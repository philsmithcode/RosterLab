<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>RosterLab</title>
  <style>
    :root {
      --bg: #0f172a;
      --panel: #111827;
      --accent: #38bdf8;
      --text: #e5e7eb;
      --muted: #9ca3af;
      --border: #1f2937;
      --danger: #f43f5e;
      --success: #22c55e;
      --mono: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      background: radial-gradient(circle at 20% 20%, #0b1224, #0a0f1f 50%, #090d18 100%);
      color: var(--text);
      font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      padding: 24px;
    }
    h1 { margin: 0 0 16px; font-size: 24px; letter-spacing: 0.4px; }
    .card {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 18px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.45);
      max-width: 1100px;
      margin: 0 auto 18px;
    }
    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 12px;
    }
    label {
      display: flex;
      flex-direction: column;
      gap: 6px;
      font-size: 13px;
      color: var(--muted);
    }
    input, select, button, textarea {
      width: 100%;
      padding: 10px 12px;
      background: #0b162c;
      border: 1px solid var(--border);
      border-radius: 10px;
      color: var(--text);
      font-size: 14px;
    }
    textarea { min-height: 44px; resize: vertical; }
    button {
      background: linear-gradient(135deg, #3b82f6, #06b6d4);
      border: none;
      cursor: pointer;
      font-weight: 600;
      transition: transform 120ms ease, box-shadow 120ms ease;
    }
    button:hover { transform: translateY(-1px); box-shadow: 0 8px 20px rgba(56,189,248,0.3); }
    .row {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
      margin-top: 12px;
    }
    .results { margin-top: 10px; }
    .result {
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px;
      margin-top: 10px;
      background: #0c1426;
    }
    .muted { color: var(--muted); font-size: 13px; }
    .pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 8px;
      border-radius: 999px;
      background: rgba(56,189,248,0.15);
      color: var(--text);
      font-size: 12px;
      font-family: var(--mono);
      margin-right: 6px;
    }
    .error {
      color: var(--danger);
      margin-top: 8px;
      font-size: 14px;
    }
    .badge { color: var(--success); font-size: 12px; margin-left: 6px; }
    .list { margin: 6px 0 0 0; padding-left: 16px; }
    code { font-family: var(--mono); }
    @media (max-width: 640px) {
      body { padding: 16px; }
      .card { padding: 14px; }
    }
  </style>
</head>
<body>
  <div class="card">
    <h1>RosterLab</h1>
    <div class="grid">
      <label>Team
        <select id="team"></select>
      </label>
      <label>TV (in thousands)
        <input type="number" id="tv" value="1000" min="1" />
      </label>
      <label>Min players
        <input type="number" id="minPlayers" value="11" min="0" />
      </label>
      <label>Max players
        <input type="number" id="maxPlayers" value="16" min="0" />
      </label>
      <label>Max results
        <input type="number" id="maxResults" value="20" min="1" />
      </label>
      <label>Sort by
        <select id="sort">
          <option value="cost">Cost (desc)</option>
          <option value="players">Players (desc)</option>
        </select>
      </label>
      <label>Rerolls (exact, optional)
        <input type="number" id="rerolls" placeholder="leave blank" min="0" />
      </label>
      <label>Require positionals (comma list, e.g. Blitzer:2,Catcher:1)
        <input type="text" id="require" placeholder="Blitzer:2,Catcher:1" />
      </label>
      <label>Require extras (comma list, e.g. Bribe:1,Apothecary:1)
        <input type="text" id="requireExtra" placeholder="Bribe:1,Apothecary:1" />
      </label>
      <label>Require mode (positionals)
        <select id="requireMode">
          <option value="all">All (default)</option>
          <option value="any">Any</option>
        </select>
      </label>
      <label>Require mode (extras)
        <select id="requireExtraMode">
          <option value="all">All (default)</option>
          <option value="any">Any</option>
        </select>
      </label>
    </div>
    <div class="row">
      <button id="generate">Generate</button>
      <span class="muted">Constraints mirror the CLI flags; change TV/requirements then generate.</span>
    </div>
    <div id="error" class="error"></div>
    <div id="results" class="results"></div>
  </div>

  <script>
    let rosters = {};
    const teamSelect = document.getElementById('team');
    const rosterReady = loadRosters();

    document.getElementById('generate').addEventListener('click', async () => {
      await rosterReady;
      const errorEl = document.getElementById('error');
      errorEl.textContent = '';
      try {
        const settings = collectSettings();
        const combos = generateCombos(rosters[settings.team].positions, settings);
        renderResults(rosters[settings.team].name, settings, combos);
      } catch (err) {
        errorEl.textContent = err.message || String(err);
      }
    });

    async function loadRosters() {
      const errorEl = document.getElementById('error');
      try {
        const res = await fetch('bb2025_rosters.json');
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        rosters = addAliases(await res.json());
        populateTeamSelect(rosters);
      } catch (err) {
        console.error('Failed to load rosters', err);
        errorEl.textContent = 'Could not load roster data.';
      }
    }

    function populateTeamSelect(rosterMap) {
      teamSelect.innerHTML = '';
      const seen = new Set();
      Object.entries(rosterMap)
        .sort((a, b) => a[1].name.localeCompare(b[1].name))
        .forEach(([key, team]) => {
          if (seen.has(team.name)) return;
          seen.add(team.name);
          const opt = document.createElement('option');
          opt.value = key;
          opt.textContent = team.name;
          teamSelect.appendChild(opt);
        });
    }

    function addAliases(map) {
      const aliases = {
        humans: 'human',
        orcs: 'orc',
        dwarfs: 'dwarf',
      };
      Object.entries(aliases).forEach(([alias, key]) => {
        if (map[key]) map[alias] = map[key];
      });
      return map;
    }

    function collectSettings() {
      if (!Object.keys(rosters).length) throw new Error('Rosters not loaded yet.');
      const tv = Number(document.getElementById('tv').value);
      const minPlayers = Number(document.getElementById('minPlayers').value);
      const maxPlayers = Number(document.getElementById('maxPlayers').value);
      const maxResults = Number(document.getElementById('maxResults').value || 20);
      const sort = document.getElementById('sort').value;
      const rerollVal = document.getElementById('rerolls').value;
      const require = document.getElementById('require').value.trim();
      const requireExtra = document.getElementById('requireExtra').value.trim();
      const requireMode = document.getElementById('requireMode').value;
      const requireExtraMode = document.getElementById('requireExtraMode').value;
      const team = document.getElementById('team').value;

      if (!team) throw new Error('Please select a team.');
      if (!tv || tv <= 0) throw new Error('Provide a positive TV in thousands.');
      if (maxPlayers < minPlayers) throw new Error('Max players must be >= min players.');
      const rerolls = rerollVal === '' ? undefined : Number(rerollVal);
      if (rerolls !== undefined && (Number.isNaN(rerolls) || rerolls < 0)) {
        throw new Error('Rerolls must be a non-negative number.');
      }

      const required = require ? parseRequirements(require) : [];
      const requiredExtras = requireExtra ? parseRequirements(requireExtra) : [];
      if (require && (!required || !required.length)) throw new Error('Invalid require format. Use Name:count.');
      if (requireExtra && (!requiredExtras || !requiredExtras.length)) throw new Error('Invalid requireExtra format. Use Name:count.');

      return {
        team,
        tv,
        minPlayers,
        maxPlayers,
        maxResults,
        sort,
        rerolls,
        required,
        requiredExtras,
        requireMode,
        requireExtraMode,
      };
    }

    function renderResults(teamName, settings, combos) {
      const container = document.getElementById('results');
      container.innerHTML = '';
      const header = document.createElement('div');
      header.className = 'muted';
      header.textContent = `Team: ${teamName} • Target TV: ${settings.tv}k • Results: ${Math.min(settings.maxResults, combos.length)} of ${combos.length || 0}`;
      container.appendChild(header);

      if (!combos.length) {
        const none = document.createElement('div');
        none.className = 'error';
        none.textContent = 'No combinations found under the given constraints.';
        container.appendChild(none);
        return;
      }

      combos.slice(0, settings.maxResults).forEach((combo, idx) => {
        const card = document.createElement('div');
        card.className = 'result';
        const title = document.createElement('div');
        title.innerHTML = `<strong>#${idx + 1}</strong> | Cost: ${combo.cost}k | Players: ${combo.totalPlayers}`;
        card.appendChild(title);

        const pills = document.createElement('div');
        pills.style.marginTop = '6px';
        pills.innerHTML = `
          <span class="pill">positionals: ${combo.positionals}</span>
          <span class="pill">linemen: ${combo.linemen}</span>
          <span class="pill">rerolls: ${combo.rerolls}</span>
        `;
        card.appendChild(pills);

        const list = document.createElement('ul');
        list.className = 'list';
        combo.players
          .filter(p => p.count > 0)
          .forEach(p => {
            const li = document.createElement('li');
            li.textContent = `${p.count} x ${p.name} @ ${p.cost}k`;
            list.appendChild(li);
          });
        card.appendChild(list);
        container.appendChild(card);
      });
    }

    function parseRequirements(str) {
      const pieces = str.split(',');
      const parsed = pieces
        .map(piece => {
          const parts = piece.split(':');
          if (!parts[0]) return null;
          const name = parts[0].trim().toLowerCase();
          const count = parts[1] ? Number(parts[1]) : 1;
          if (!name || Number.isNaN(count) || count <= 0) return null;
          return { name, count };
        })
        .filter(Boolean);
      return parsed.length ? parsed : null;
    }

    function generateCombos(positions, settings) {
      let results = [];
      const path = [];
      let bestCost = 0;

      function dfs(index, remainingCost, totalPlayers) {
        if (totalPlayers >= settings.minPlayers) {
          const spent = settings.tv - remainingCost;
          const summary = path.reduce(
            (acc, p) => {
              if (!p.count) return acc;
              const type = p.type ?? 'player';
              const name = (p.name || '').toLowerCase();
              if (type === 'extra' && name === 'reroll') acc.rerolls += p.count;
              if (type === 'player') {
                const isLineman = p.role === 'lineman' || name.includes('lineman');
                if (isLineman) acc.lineman += p.count;
                else acc.positionals += p.count;
              }
              if (settings.required && settings.required.length) {
                const req = settings.required.find(r => r.name === name);
                if (req) acc.required[name] = (acc.required[name] ?? 0) + p.count;
              }
              if (settings.requiredExtras && settings.requiredExtras.length) {
                const req = settings.requiredExtras.find(r => r.name === name);
                if (req) acc.requiredExtras[name] = (acc.requiredExtras[name] ?? 0) + p.count;
              }
              return acc;
            },
            { rerolls: 0, positionals: 0, lineman: 0, required: {}, requiredExtras: {} }
          );

          const missingRequired = settings.required && settings.required.some(
            r => (summary.required[r.name] ?? 0) < r.count
          );
          const missingRequiredExtras = settings.requiredExtras && settings.requiredExtras.some(
            r => (summary.requiredExtras[r.name] ?? 0) < r.count
          );

          const failsRequiredAny = settings.requireMode === 'any' &&
            settings.required.length > 0 &&
            settings.required.every(r => (summary.required[r.name] ?? 0) < r.count);
          const failsRequiredAll = settings.requireMode === 'all' && missingRequired;

          const failsExtrasAny = settings.requireExtraMode === 'any' &&
            settings.requiredExtras.length > 0 &&
            settings.requiredExtras.every(r => (summary.requiredExtras[r.name] ?? 0) < r.count);
          const failsExtrasAll = settings.requireExtraMode === 'all' && missingRequiredExtras;

          if (
            (settings.rerolls !== undefined && summary.rerolls !== settings.rerolls) ||
            failsRequiredAny ||
            failsRequiredAll ||
            failsExtrasAny ||
            failsExtrasAll
          ) {
            // keep exploring
          } else if (spent > bestCost) {
            bestCost = spent;
            results = [{
              players: [...path],
              cost: spent,
              totalPlayers,
              rerolls: summary.rerolls,
              positionals: summary.positionals,
              linemen: summary.lineman,
            }];
          } else if (spent === bestCost) {
            results.push({
              players: [...path],
              cost: spent,
              totalPlayers,
              rerolls: summary.rerolls,
              positionals: summary.positionals,
              linemen: summary.lineman,
            });
          }
          // continue exploring to see if we can spend closer to cap
        }

        if (index >= positions.length || remainingCost <= 0) return;

        const pos = positions[index];
        const isPlayer = (pos.type ?? 'player') === 'player';
        const maxByCost = Math.floor(remainingCost / pos.cost);
        const playerRoom = isPlayer ? settings.maxPlayers - totalPlayers : Number.MAX_SAFE_INTEGER;
        const maxCount = Math.min(pos.max, maxByCost, playerRoom);

        for (let count = 0; count <= maxCount; count++) {
          path.push({ name: pos.name, count, cost: pos.cost, type: pos.type, role: pos.role });
          const nextPlayers = isPlayer ? totalPlayers + count : totalPlayers;
          dfs(index + 1, remainingCost - count * pos.cost, nextPlayers);
          path.pop();
        }
      }

      dfs(0, settings.tv, 0);

      return results
        .filter(r => r.totalPlayers <= settings.maxPlayers)
        .sort((a, b) => {
          if (settings.sort === 'players') {
            return (
              b.totalPlayers - a.totalPlayers ||
              b.positionals - a.positionals ||
              a.linemen - b.linemen ||
              b.cost - a.cost ||
              b.rerolls - a.rerolls ||
              0
            );
          }
          return (
            b.cost - a.cost ||
            b.totalPlayers - a.totalPlayers ||
            b.positionals - a.positionals ||
            a.linemen - b.linemen ||
            b.rerolls - a.rerolls ||
            0
          );
        });
    }

  </script>
</body>
</html>
