<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>RosterLab</title>
  <link rel="icon" type="image/png" href="wmino.png" />
  <style>
    :root {
      --bg: #0f172a;
      --panel: #111827;
      --accent: #38bdf8;
      --text: #e5e7eb;
      --muted: #9ca3af;
      --border: #1f2937;
      --danger: #f43f5e;
      --success: #22c55e;
      --mono: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      background: radial-gradient(circle at 20% 20%, #0b1224, #0a0f1f 50%, #090d18 100%);
      color: var(--text);
      font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      padding: 24px;
    }
    h1 { margin: 0 0 16px; font-size: 24px; letter-spacing: 0.4px; }
    .card {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 18px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.45);
      max-width: 1100px;
      margin: 0 auto 18px;
    }
    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 12px;
    }
    label {
      display: flex;
      flex-direction: column;
      gap: 6px;
      font-size: 13px;
      color: var(--muted);
    }
    input, select, button, textarea {
      width: 100%;
      padding: 10px 12px;
      background: #0b162c;
      border: 1px solid var(--border);
      border-radius: 10px;
      color: var(--text);
      font-size: 14px;
    }
    textarea { min-height: 44px; resize: vertical; }
    button {
      background: linear-gradient(135deg, #3b82f6, #06b6d4);
      border: none;
      cursor: pointer;
      font-weight: 600;
      transition: transform 120ms ease, box-shadow 120ms ease;
    }
    button:hover { transform: translateY(-1px); box-shadow: 0 8px 20px rgba(56,189,248,0.3); }
    .stepper {
      display: flex;
      align-items: center;
      gap: 8px;
      width: 100%;
    }
    .stepper input[type="number"] {
      flex: 1;
      width: auto;
    }
    .stepper-btn {
      width: 38px;
      padding: 10px 0;
      background: #0b162c;
      border: 1px solid var(--border);
      color: var(--text);
      border-radius: 10px;
      font-weight: 700;
      line-height: 1;
      box-shadow: none;
    }
    .stepper-btn:disabled { opacity: 0.45; cursor: not-allowed; }
    .stepper.stepper-disabled .stepper-btn { opacity: 0.45; cursor: not-allowed; }
    .icon-btn {
      width: auto;
      min-width: 36px;
      padding: 6px 10px;
      font-size: 14px;
      line-height: 1;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
    }
    .icon-btn.secondary {
      background: #0b162c;
      border: 1px solid var(--border);
      box-shadow: none;
    }
    .icon-btn.secondary:hover { box-shadow: none; transform: translateY(-1px); }
    .row {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
      margin-top: 12px;
    }
    .results { margin-top: 10px; }
    .result {
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px;
      margin-top: 10px;
      background: #0c1426;
    }
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.65);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 50;
      padding: 16px;
    }
    .modal-card {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 14px;
      max-width: 1100px;
      width: 100%;
      max-height: 90vh;
      overflow: auto;
      padding: 16px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.55);
    }
    .modal-card table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 8px;
    }
    .modal-card th, .modal-card td {
      padding: 6px 8px;
      border-bottom: 1px solid var(--border);
      text-align: left;
      font-size: 13px;
    }
    .modal-card th {
      color: var(--muted);
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.3px;
    }
    .skills-wide { width: 24%; }
    .modal-card .text-center { text-align: center; }
    .subtle { color: var(--muted); font-size: 12px; }
    .muted { color: var(--muted); font-size: 13px; }
    .pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 8px;
      border-radius: 999px;
      background: rgba(56,189,248,0.15);
      color: var(--text);
      font-size: 12px;
      font-family: var(--mono);
      margin-right: 6px;
    }
    .error {
      color: var(--danger);
      margin-top: 8px;
      font-size: 14px;
    }
    .badge { color: var(--success); font-size: 12px; margin-left: 6px; }
    .list { margin: 6px 0 0 0; padding-left: 16px; }
    code { font-family: var(--mono); }
    @media (max-width: 640px) {
      body { padding: 16px; }
      .card { padding: 14px; }
    }
  </style>
</head>
<body>
  <div class="card">
    <div class="row" style="justify-content: space-between; align-items: center; margin-top: 0;">
      <h1 style="margin: 0; display: inline-flex; align-items: center; gap: 8px;">
        <a href="img/v03.png" target="_blank" rel="noopener" style="display:inline-flex; align-items:center;">
          <img src="img/v03.png" alt="RosterLab icon" style="width: 28px; height: 28px; border-radius: 6px;" />
        </a>
        RosterLab v0.3
      </h1>
      <button id="guideToggle" type="button" style="max-width: 160px;">Show guide</button>
    </div>
    <p id="userGuide" class="muted" style="margin-top: 10px; display: none;">Use the tool to pick your team, set your TV (in thousands), choose min/max players, and decide how many results you want per page. You can sort by total cost or by number of players, and even lock in exact rerolls if you like. If you want to force certain choices—like minimum numbers of positionals, up to two star players, a set number of bribes, or taking an apothecary—add those too. Hit Generate to see valid roster combinations, then flip through the pages to explore them. If nothing appears, ease your constraints by raising TV, lowering player minimums, or relaxing forced choices. Tweak, regenerate, and experiment until you find the perfect Blood Bowl roster.</p>

    <div class="grid">
      <label>Team
        <select id="team"></select>
      </label>
      <label>TV (in thousands)
        <input type="number" id="tv" value="1000" min="1" step="10" />
      </label>
      <label>Min players
        <input type="number" id="minPlayers" value="11" min="0" />
      </label>
      <label>Max players
        <input type="number" id="maxPlayers" value="16" min="0" />
      </label>
      <label>Max results per page
        <input type="number" id="maxResults" value="5" min="1" />
      </label>
      <label>Sort by
        <select id="sort">
          <option value="cost">Cost (desc)</option>
          <option value="players">Players (desc)</option>
        </select>
      </label>
      <label>Rerolls (exact, optional)
        <input type="number" id="rerolls" placeholder="leave blank" min="0" />
      </label>
      <label>Positionals to force (enter minimums)
        <div id="positionalList"></div>
      </label>
      <label>Bribes (exact, optional)
        <input type="number" id="bribes" value="0" placeholder="leave blank" min="0" />
      </label>
      <label>Apothecary (exact, optional)
        <input type="number" id="apothecary" placeholder="0 or 1, leave blank to skip" min="0" max="1" />
      </label>
      <label id="riotousRookiesField" style="display: none;">Riotous rookies (optional)
        <input type="number" id="riotousRookies" value="0" placeholder="only for Ogres/Snotlings" min="0" />
      </label>
      <label>Star player 1 (optional)
        <select id="star1"></select>
      </label>
      <label>Star player 2 (optional)
        <select id="star2"></select>
      </label>
    </div>
    <div class="row">
      <button id="generate">Generate</button>
      <span class="muted">Constraints mirror the CLI flags; change TV/requirements then generate.</span>
    </div>
    <div id="error" class="error"></div>
    <div id="results" class="results"></div>
    <div class="row">
      <button id="prevPage" disabled>Prev</button>
      <button id="nextPage" disabled>Next</button>
      <span id="pageInfo" class="muted"></span>
    </div>
    <div class="row" style="margin-top: 4px;">
      <label style="flex: 1 1 auto; align-items: center; gap: 8px; display: inline-flex; color: var(--muted);">
        <input type="checkbox" id="detailedView" checked style="width: auto; accent-color: var(--accent);" />
        Use detailed per-player roster view
      </label>
    </div>
  </div>

  <div id="detailModal" class="modal-overlay" role="dialog" aria-modal="true">
    <div class="modal-card">
      <div class="row" style="justify-content: space-between; align-items: center; margin: 0 0 8px 0;">
        <div id="detailTitle" style="font-weight: 700; font-size: 16px;"></div>
        <div class="row" style="gap: 8px; flex-wrap: wrap; justify-content: flex-end; margin-top: 0;">
          <button id="detailExport" type="button" class="icon-btn secondary" style="width: auto; min-width: 0;">Export PDF</button>
          <button id="detailClose" type="button" class="icon-btn secondary" style="width: auto; min-width: 0;">Close</button>
        </div>
      </div>
      <div id="detailContent"></div>
    </div>
  </div>

  <script>
    let rosters = {};
    let lastCombos = null;
    let currentPage = 1;
    let pageSize = 5;
    const addedSkillsStore = {};
    const lastDetailContext = { teamKey: null, teamName: null, settings: null, combo: null, rank: null, teamTitle: null, detailed: true };
    const skillCatalog = {
      G: ["Block","Dauntless","Fend","Frenzy*","Kick","Pro","Steady Footing","Strip Ball","Sure Hands","Tackle","Taunt","Wrestle"],
      A: ["Catch","Defensive","Diving Catch","Diving Tackle","Dodge","Hit and Run","Jump up","Leap","Safe Pair of Hands","Sidestep","Sprint","Sure Feet"],
      S: ["Arm Bar","Brawler","Break Tackle","Bullseye","Grab","Guard","Juggernaut","Mighty Blow","Multiple Block","Stand Firm","Strong Arm","Thick Skull"],
      P: ["Accurate","Cannoneer","Cloud Burster","Dump-off","Give and Go","Hail Mary Pass","Leader","Nerves of Steel","On the Ball","Pass","Punt","Safe Pass"],
      M: ["Big Hand","Claws","Disturbing Presence*","Extra Arms","Foul Appearance","Horns","Iron Hard Skin","Monstrous Mouth","Prehensile Tail","Tentacles","Two Heads","Very Long Legs"],
      D: ["Dirty Player","Eye Gouge","Fumblerooski","Lethal Flight","Lone Fouler","Pile Driver","Put the Boot In","Quick Foul","Saboteur","Shadowing","Sneaky Git","Violent Innovator"],
    };
    const teamSelect = document.getElementById('team');
    const starSelect1 = document.getElementById('star1');
    const starSelect2 = document.getElementById('star2');
    const bribesInput = document.getElementById('bribes');
    const apothecaryInput = document.getElementById('apothecary');
    const rookiesInput = document.getElementById('riotousRookies');
    const rookiesField = document.getElementById('riotousRookiesField');
    const positionalList = document.getElementById('positionalList');
    const rosterReady = loadRosters();
    const guideToggle = document.getElementById('guideToggle');
    const userGuide = document.getElementById('userGuide');
    const detailModal = document.getElementById('detailModal');
    const detailContent = document.getElementById('detailContent');
    const detailTitle = document.getElementById('detailTitle');
    const detailClose = document.getElementById('detailClose');
    const detailExport = document.getElementById('detailExport');
    const detailedViewToggle = document.getElementById('detailedView');
    let lastDetailHtml = '';
    let lastDetailTitle = '';
    document.querySelectorAll('input[type="number"]').forEach(applyStepper);

    teamSelect.addEventListener('change', () => {
      populateStarSelects(teamSelect.value);
      updateBribeInput(teamSelect.value);
      updateApothecaryInput(teamSelect.value);
      updateRiotousRookiesInput(teamSelect.value);
      populatePositionalList(teamSelect.value);
    });

    starSelect1.addEventListener('change', () => enforceDistinctStars(starSelect1, starSelect2));
    starSelect2.addEventListener('change', () => enforceDistinctStars(starSelect2, starSelect1));

    document.getElementById('generate').addEventListener('click', async () => {
      await rosterReady;
      const errorEl = document.getElementById('error');
      errorEl.textContent = '';
      try {
        const settings = collectSettings();
        const positions = buildPositions(
          rosters[settings.team],
          settings.stars,
          settings.maxStars,
          settings.bribes,
          settings.riotousRookies,
          settings.apothecary
        );
        const combos = generateCombos(positions, settings);
        lastCombos = { teamName: rosters[settings.team].name, settings, combos };
        currentPage = 1;
        pageSize = maxResults;
        renderResults(rosters[settings.team].name, settings, combos);
      } catch (err) {
        errorEl.textContent = err.message || String(err);
      }
    });

    document.getElementById('prevPage').addEventListener('click', () => {
      if (!lastCombos) return;
      if (currentPage > 1) {
        currentPage--;
        renderResults(lastCombos.teamName, lastCombos.settings, lastCombos.combos);
      }
    });

    document.getElementById('nextPage').addEventListener('click', () => {
      if (!lastCombos) return;
      const totalPages = Math.max(1, Math.ceil(lastCombos.combos.length / pageSize));
      if (currentPage < totalPages) {
        currentPage++;
        renderResults(lastCombos.teamName, lastCombos.settings, lastCombos.combos);
      }
    });

    guideToggle.addEventListener('click', () => {
      const hidden = userGuide.style.display === 'none';
      userGuide.style.display = hidden ? 'block' : 'none';
      guideToggle.textContent = hidden ? 'Hide guide' : 'Show guide';
    });
    detailClose.addEventListener('click', hideDetailModal);
    detailExport.addEventListener('click', exportDetailPdf);
    detailModal.addEventListener('click', (evt) => {
      if (evt.target === detailModal) hideDetailModal();
    });

    async function loadRosters() {
      const errorEl = document.getElementById('error');
      try {
        const res = await fetch('bb2025_rosters_detailed.json');
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        rosters = addAliases(await res.json());
        populateTeamSelect(rosters);
        populateStarSelects(teamSelect.value);
        updateBribeInput(teamSelect.value);
        updateApothecaryInput(teamSelect.value);
        updateRiotousRookiesInput(teamSelect.value);
        populatePositionalList(teamSelect.value);
      } catch (err) {
        console.error('Failed to load rosters', err);
        errorEl.textContent = 'Could not load roster data.';
      }
    }

    function populateTeamSelect(rosterMap) {
      teamSelect.innerHTML = '';
      const seen = new Set();
      Object.entries(rosterMap)
        .sort((a, b) => a[1].name.localeCompare(b[1].name))
        .forEach(([key, team]) => {
          if (seen.has(team.name)) return;
          seen.add(team.name);
          const opt = document.createElement('option');
          opt.value = key;
          opt.textContent = team.name;
          teamSelect.appendChild(opt);
        });
      if (teamSelect.options.length) {
        // ensure a value is selected so downstream populators have a key
        teamSelect.selectedIndex = 0;
        const sel = teamSelect.value;
        populateStarSelects(sel);
        updateBribeInput(sel);
        updateApothecaryInput(sel);
        updateRiotousRookiesInput(sel);
      } else {
        populateStarSelects('');
        updateBribeInput('');
        updateApothecaryInput('');
        updateRiotousRookiesInput('');
      }
    }

    function populateStarSelects(teamKey) {
      const roster = rosters[teamKey];
      const stars = roster?.starPlayers || [];
      const selects = [starSelect1, starSelect2];
      selects.forEach(sel => {
        sel.innerHTML = '';
        const none = document.createElement('option');
        none.value = '';
        none.textContent = stars.length ? 'None' : 'No stars available';
        sel.appendChild(none);
        stars.forEach(sp => {
          const opt = document.createElement('option');
          opt.value = sp.name;
          opt.textContent = `${sp.name} (${sp.cost}k)`;
          sel.appendChild(opt);
        });
        sel.disabled = false; // keep enabled even if empty to avoid lock-out
      });
    }

    function getBribeInfo(teamKeyOrObj) {
      const roster = typeof teamKeyOrObj === 'string' ? rosters[teamKeyOrObj] : teamKeyOrObj;
      const inds = roster?.inducements || [];
      const found = inds.find(i => (i.name || '').toLowerCase().includes('bribe'));
      if (!found) return null;
      const maxMatch = /0-(\d+)/i.exec(found.name || '');
      const max = maxMatch ? Number(maxMatch[1]) : (found.max ?? 3);
      const cost = Number(found.cost) || 100;
      return { cost, max };
    }

    function getApothecaryInfo(teamKeyOrObj) {
      const roster = typeof teamKeyOrObj === 'string' ? rosters[teamKeyOrObj] : teamKeyOrObj;
      const pos = (roster?.positions || []).find(p => (p.name || '').toLowerCase() === 'apothecary');
      if (!pos) return null;
      const max = Number(pos.max ?? 1);
      const cost = Number(pos.cost) || 50;
      return { cost, max };
    }

    function getRiotousRookiesInfo(teamKeyOrObj) {
      const roster = typeof teamKeyOrObj === 'string' ? rosters[teamKeyOrObj] : teamKeyOrObj;
      const inds = roster?.inducements || [];
      const found = inds.find(i => (i.name || '').toLowerCase().includes('riotous rookies'));
      if (!found) return null;
      const maxMatch = /0-(\d+)/i.exec(found.name || '');
      const max = maxMatch ? Number(maxMatch[1]) : (found.max ?? 1);
      const cost = Number(found.cost) || 150;
      return { cost, max };
    }

    function updateBribeInput(teamKey) {
      const info = getBribeInfo(teamKey);
      if (!info) {
        bribesInput.value = '0';
        bribesInput.disabled = true;
        bribesInput.placeholder = 'not available';
        return;
      }
      bribesInput.disabled = false;
      bribesInput.min = '0';
      bribesInput.max = String(info.max);
      bribesInput.placeholder = `0..${info.max} @ ${info.cost}k`;
      const current = Number(bribesInput.value || 0);
      if (Number.isNaN(current) || current < 0 || current > info.max) {
        bribesInput.value = '0';
      }
    }

    function updateApothecaryInput(teamKey) {
      const info = getApothecaryInfo(teamKey);
      if (!info) {
        apothecaryInput.value = '';
        apothecaryInput.disabled = true;
        apothecaryInput.placeholder = 'not available';
        return;
      }
      apothecaryInput.disabled = false;
      apothecaryInput.min = '0';
      apothecaryInput.max = String(info.max);
      apothecaryInput.placeholder = `0..${info.max} @ ${info.cost}k`;
      const current = apothecaryInput.value === '' ? undefined : Number(apothecaryInput.value);
      if (current === undefined) return;
      if (Number.isNaN(current) || current < 0 || current > info.max) {
        apothecaryInput.value = '';
      }
    }

    function updateRiotousRookiesInput(teamKey) {
      const info = getRiotousRookiesInfo(teamKey);
      if (!info) {
        rookiesInput.value = '0';
        rookiesInput.disabled = true;
        rookiesInput.placeholder = 'not available';
        rookiesField.style.display = 'none';
        return;
      }
      rookiesField.style.display = 'block';
      rookiesInput.disabled = false;
      rookiesInput.min = '0';
      rookiesInput.max = String(info.max);
      rookiesInput.placeholder = `0..${info.max} @ ${info.cost}k`;
      const current = Number(rookiesInput.value || 0);
      if (Number.isNaN(current) || current < 0 || current > info.max) {
        rookiesInput.value = '0';
      }
    }

    function populatePositionalList(teamKey) {
      const roster = rosters[teamKey];
      positionalList.innerHTML = '';
      if (!roster) return;
      const players = (roster.positions || []).filter(p => (p.type ?? 'player') === 'player');
      players.forEach(pos => {
        const row = document.createElement('div');
        row.className = 'row';
        row.style.alignItems = 'center';
        row.style.gap = '8px';
        const label = document.createElement('div');
        label.textContent = `${pos.name} (max ${pos.max})`;
        const input = document.createElement('input');
        input.type = 'number';
        input.min = '0';
        input.max = String(pos.max);
        input.value = '0';
        input.dataset.name = pos.name;
        row.appendChild(label);
        row.appendChild(input);
        applyStepper(input);
        positionalList.appendChild(row);
      });
    }

    function addAliases(map) {
      const aliases = {
        humans: 'human',
        orcs: 'orc',
        dwarfs: 'dwarf',
      };
      Object.entries(aliases).forEach(([alias, key]) => {
        if (map[key]) map[alias] = map[key];
      });
      return map;
    }

    function getTeamNamePool(teamKey, rosterName) {
      const key = (teamKey || '').toLowerCase();
      const name = (rosterName || '').toLowerCase();
      const basePools = {
        human: ['Guardians', 'Sentinels', 'Rangers', 'Pilots', 'Commanders', 'Stallions', 'Legion', 'Outriders', 'Minutemen', 'Warriors', 'Vanguards', 'Titans', 'Chargers'],
        amazon: ['Serpents', 'Jaguars', 'Eagles', 'Pythons', 'Storm Maidens', 'Sun Spears', 'Valkyries', 'Blaze', 'Vipers'],
        'imperial-nobility': ['Barons', 'Lancers', 'Royals', 'Cavaliers', 'Legates', 'Dynasts', 'Kingsmen'],
        bretonnian: ['Chevaliers', 'Lions', 'Grail Knights', 'Falcons', 'Lancers', 'Crusaders'],
        'black-orc': ['Bruisers', 'Maulers', 'Skullcrushers', 'Iron Tusks', 'Bruising Bulls', 'Rampage'],
        orc: ['Brawlers', 'Crushers', 'Bashers', 'Tusks', 'Grimjaws', 'Bruisers'],
        goblin: ['Sneaks', 'Bog Jumpers', 'Mischiefs', 'Snots', 'Boomers', 'Tricksters'],
        snotling: ['Mudskippers', 'Gnats', 'Grubs', 'Scramblers', 'Bog Hoppers', 'Skippers'],
        ogre: ['Maulers', 'Boulderbacks', 'Stonefists', 'Anvils', 'Titans', 'Mammoths'],
        dwarf: ['Anvils', 'Ramparts', 'Forgeguard', 'Stonehammers', 'Mountaineers', 'Ironclads'],
        'chaos-dwarf': ['Inferno', 'Bullheads', 'Ash Raiders', 'Hellforged', 'Overlords', 'Havoc'],
        elf: ['Falcons', 'Skyblades', 'Starlight', 'Sentinels', 'Windrunners', 'Wildcats'],
        'dark-elf': ['Shadows', 'Ravens', 'Corsairs', 'Nightblades', 'Black Arrows', 'Reavers'],
        'high-elf': ['Arcanists', 'Lancers', 'Sunspears', 'Pride', 'Skyhawks', 'Royals'],
        'elven-union': ['Wardens', 'Gliders', 'Silver Arrows', 'Wavebreakers', 'Striders'],
        'wood-elf': ['Wildrunners', 'Sylvans', 'Wardancers', 'Glades', 'Barkhawks', 'Forest Hawks'],
        skaven: ['Skitterers', 'Warpclaws', 'Plaguewind', 'Gnawers', 'Underfeet', 'Ratskins'],
        lizardmen: ['Sunfangs', 'Junglebacks', 'Scaleguard', 'Marsh Raptors', 'Thunder Lizards', 'Swamp Stalkers'],
        gnome: ['Tricksters', 'Tinkerers', 'Riveters', 'Cogs', 'Quickfoots', 'Gadgets'],
        halfling: ['Stouthearts', 'Pieslingers', 'Harvesters', 'Haybales', 'Hilltop', 'Acorns'],
        nurgle: ['Rotwings', 'Blight', 'Carrion', 'Muckrunners', 'Decay', 'Spores'],
        'chaos-chosen': ['Ravagers', 'Dreadlords', 'Harbingers', 'Ruiners', 'Desecrators', 'Raiders'],
        'chaos-renegade': ['Outcasts', 'Reavers', 'Despoilers', 'Betrayers', 'Warpspawn', 'Renegades'],
        khorne: ['Bloodhounds', 'Skulls', 'Butchers', 'Gorefury', 'Red Tide', 'Berserkers'],
        vampire: ['Nightwings', 'Crimson', 'Bloodlines', 'Moonveil', 'Nocturnes', 'Shadows'],
        'necromantic-horror': ['Gravewalkers', 'Moongrim', 'Pallbearers', 'Night Howlers', 'Shadelords', 'Phantoms'],
        'shambling-undead': ['Graveguard', 'Bonewalkers', 'Tombstorm', 'Deathrattle', 'Pale Legion', 'Wraiths'],
        'tomb-kings': ['Dynasty', 'Pharaohs', 'Sunscarabs', 'Eternals', 'Obelisks', 'Scarab Kings'],
        norse: ['Raiders', 'Frostfangs', 'Berserkers', 'Icewolves', 'Longboats', 'Stormborn'],
        'underworld-denizens': ['Warped', 'Burrowers', 'Tunnellers', 'Madcaps', 'Grotmass', 'Nightcrawlers'],
      };
      const cityPools = {
        human: ['Empire City', 'Steel Harbor', 'Crown Point', 'Rivergate', 'Lone Star', 'Bayport'],
        amazon: ['Sunspire', 'Jungle Bay', 'Rainport', 'Serpent Bay', 'Sky Temple'],
        orc: ['Ironjaw', 'Blackfang', 'Red Crag', 'Grimmoor'],
        dwarf: ['Stonehold', 'Deepforge', 'Anvil Bay', 'Hammerfall'],
        elf: ['Silverglade', 'Starhaven', 'Highspire', 'Brightwind'],
        skaven: ['Underkeep', 'Warrens', 'Sewerpoint', 'Skittergate'],
        lizardmen: ['Xotl', 'Zlan Ridge', 'Marshpoint', 'Tepok Bay'],
        halfling: ['Hillshire', 'Greenfield', 'Oakvale', 'Meadowbrook'],
        vampire: ['Nightshade', 'Crimson Hollow', 'Duskhaven', 'Mooncrest'],
        undead: ['Gravehaven', 'Bonefield', 'Ghoulcrest', 'Tombrook'],
        chaos: ['Warped Reach', 'Dreadmoor', 'Ruinport', 'Blightgate'],
        norse: ['Frostholm', 'Longfjord', 'Stormfjord', 'Icebay'],
        goblin: ['Bog Bottom', 'Swamptown', 'Muckport', 'Grotto Bay'],
      };
      const nicknamePool = basePools[name] || basePools[key] || (name.includes('elf') ? basePools.elf : (name.includes('orc') ? basePools['black-orc'] : null)) || ['Guardians', 'Defenders', 'Blitz', 'Legion', 'Thunder', 'Storm', 'Titans', 'Falcons'];
      const cityPool =
        cityPools[key] ||
        cityPools[name] ||
        (name.includes('elf') ? cityPools.elf : null) ||
        (name.includes('orc') ? cityPools.orc : null) ||
        cityPools.human ||
        ['Metro City', 'Harbor Bay', 'Capital', 'Great Plains'];
      return { nicknamePool, cityPool };
    }

    function generateTeamName(teamKey, rosterName, seedSalt = '') {
      const { nicknamePool, cityPool } = getTeamNamePool(teamKey, rosterName);
      const rng = seededRandom(`teamname|${teamKey}|${rosterName}|${seedSalt}`);
      const nick = nicknamePool[Math.floor(rng() * nicknamePool.length) % nicknamePool.length];
      const city = cityPool[Math.floor(rng() * cityPool.length) % cityPool.length];
      return `${city} ${nick}`;
    }

    function sanitizeTeamBase(name) {
      if (!name) return 'Squad';
      return name.replace(/[^a-z0-9]+/gi, ' ').trim();
    }

    function enforceDistinct(changed, other) {
      if (changed.value && changed.value === other.value) {
        other.value = '';
      }
    }

    function enforceDistinctStars(changed, other) {
      if (changed.value && changed.value === other.value) {
        other.value = '';
      }
    }

    function seededRandom(seedStr) {
      let h = 2166136261 >>> 0;
      for (let i = 0; i < seedStr.length; i++) {
        h ^= seedStr.charCodeAt(i);
        h = Math.imul(h, 16777619);
      }
      return () => {
        h += h << 13; h ^= h >>> 7; h += h << 3; h ^= h >>> 17; h += h << 5;
        return (h >>> 0) / 4294967295;
      };
    }

    function getNamePool(teamKey, rosterName) {
      const key = (teamKey || '').toLowerCase();
      const name = (rosterName || '').toLowerCase();
      const pools = {
        human: ['Marcus Crowe', 'Alric Holt', 'Jonas Pike', 'Derek Vane', 'Silas Reed', 'Corvin Hale', 'Ronan Briggs', 'Evan Talbot', 'Quinn Laird', 'Gavin Stone', 'Lyle Mercer', 'Cedric Harlow'],
        amazon: ['Ixchel', 'Tepin', 'Xoco', 'Malinali', 'Chaska', 'Yaretzi', 'Amana', 'Chilali', 'Nayeli', 'Zyanya', 'Miztli', 'Citlali'],
        'imperial-nobility': ['Sir Alden', 'Baron Urswick', 'Galen d\'Or', 'Otho Harlowe', 'Serafin Voss', 'Roland Tyne', 'Lucan Verne', 'Cassian Bright', 'Benedict Roe', 'Perrin Vale'],
        bretonnian: ['Guillaume', 'Etienne', 'Lothaire', 'Roland', 'Bastion', 'Amaury', 'Thierry', 'Alaric', 'Durand', 'Hector'],
        'black-orc': ['Graz Ironjaw', 'Morgluk', 'Grubnash', 'Skarruk', 'Draktooth', 'Gorbad', 'Hruk', 'Mogrot', 'Skorg', 'Grash'],
        orc: ['Uzgash', 'Ghazbag', 'Snaga', 'Urblok', 'Krugg', 'Dronk', 'Hargash', 'Zognar', 'Mugluk', 'Snorble'],
        goblin: ['Snikt', 'Dreggit', 'Fizzle', 'Zibzib', 'Gobbo', 'Snorbo', 'Wazzik', 'Pibz', 'Nixx', 'Grott'],
        snotling: ['Skit', 'Mib', 'Zib', 'Pok', 'Likkit', 'Nib', 'Fik', 'Splug', 'Zug', 'Prip'],
        ogre: ['Brak Boulder', 'Durk Smash', 'Grothar', 'Hrukkar', 'Mok Gut', 'Throk', 'Uldrum', 'Vorlag', 'Roknar', 'Krag'],
        dwarf: ['Thrain', 'Borin', 'Kazrik', 'Durin', 'Bromli', 'Rurik', 'Dorin', 'Grumli', 'Bardin', 'Skaggi'],
        'chaos-dwarf': ['Zhatan', 'Drakkar', 'Gorthak', 'Rhazak', 'Varkhur', 'Drazho', 'Zhorin', 'Grugni', 'Kharek', 'Zhul'],
        elf: ['Aelar', 'Calen', 'Theren', 'Erevan', 'Lathai', 'Syllin', 'Firael', 'Vaelis', 'Myrian', 'Talanis'],
        'dark-elf': ['Liraeth', 'Zereth', 'Drusil', 'Velkyn', 'Nerith', 'Zariel', 'Maelis', 'Sorath', 'Valryn', 'Rhyss'],
        'high-elf': ['Althoran', 'Caelir', 'Ithandir', 'Lorien', 'Maethor', 'Aeril', 'Thamior', 'Vaelor', 'Elandril', 'Saryth'],
        'elven-union': ['Rhenar', 'Silvan', 'Thalar', 'Valion', 'Elathis', 'Cyran', 'Nymil', 'Orlian', 'Pereth', 'Riviel'],
        'wood-elf': ['Thalion', 'Erlin', 'Fenwyn', 'Lethariel', 'Rowan', 'Sylvar', 'Tauren', 'Orin', 'Galad', 'Celion'],
        skaven: ['Snikch', 'Queek', 'Riktik', 'Skrolk', 'Vermis', 'Snarl', 'Krikt', 'Vaztik', 'Skreech', 'Razzik'],
        lizardmen: ['Xlaq', 'Tlaz', 'Zhotec', 'Qolotl', 'Zaq', 'Itza', 'Tzunki', 'Maztal', 'Chotec', 'Quenchi'],
        gnome: ['Pip Thistle', 'Milo Bramble', 'Nix Copper', 'Tinker Cob', 'Wizzle Reed', 'Fennel Gear', 'Dill Penny', 'Crispin Quick', 'Larkspur', 'Wort'],
        halfling: ['Pip Applebottom', 'Milo Greenleaf', 'Rosco Underbough', 'Finnan Goodbarrel', 'Tobias Tunnelly', 'Clover Proudfoot', 'Peony Hilltopple', 'Myrtle Meadow', 'Daisy Thornbush', 'Ruby Hedgerow'],
        nurgle: ['Pusgore', 'Rotswell', 'Phlegm', 'Mirek', 'Gristle', 'Bilemar', 'Slopdar', 'Ghurk', 'Moldrak', 'Plagrum'],
        'chaos-chosen': ['Varek', 'Zhul', 'Mordrak', 'Gorath', 'Khalgor', 'Rhazak', 'Vorgrim', 'Skarn', 'Azrak', 'Korhul'],
        'chaos-renegade': ['Rukhar', 'Zath', 'Kren', 'Malchor', 'Vesk', 'Torvak', 'Zern', 'Harrek', 'Sark', 'Velgor'],
        khorne: ['Skal Blood', 'Threx', 'Gorth', 'Kharzak', 'Vulkar', 'Drath', 'Rashak', 'Zorn', 'Skorn', 'Morgath'],
        nurgle: ['Pusgore', 'Rotswell', 'Phlegm', 'Mirek', 'Gristle', 'Bilemar', 'Slopdar', 'Ghurk', 'Moldrak', 'Plagrum'],
        vampire: ['Lucian Voss', 'Seraphine Dusk', 'Valen Night', 'Isolde Shade', 'Corvin Dray', 'Lilith Noire', 'Marius Crowl', 'Selene Vein', 'Alaric Grave', 'Ravenna'],
        'necromantic-horror': ['Jon Hollow', 'Mora Shade', 'Gregor Veil', 'Iskra Vile', 'Ulric Gloom', 'Bram Noct', 'Sable Wight', 'Nyssa Grin', 'Ghent Voss', 'Lena Dreg'],
        'shambling-undead': ['Hark Mort', 'Darius Rot', 'Lydia Grave', 'Morbus', 'Zed Nek', 'Corvash', 'Morlen', 'Ghoula', 'Varn Skul', 'Pallor'],
        'tomb-kings': ['Rahtep', 'Amenhotar', 'Khalida', 'Setra', 'Tutep', 'Nebrekh', 'Khepra', 'Osiron', 'Sutekh', 'Pharek'],
        norse: ['Bjorn', 'Sven', 'Erik', 'Leif', 'Rurik', 'Hakon', 'Torvald', 'Ulfr', 'Stig', 'Kjell'],
        'underworld-denizens': ['Snikkit', 'Drogg', 'Fizzle', 'Gritz', 'Klack', 'Vretch', 'Murt', 'Kribl', 'Skitz', 'Pug'],
      };
      const keyCandidates = [key, name];
      for (const candidate of keyCandidates) {
        if (!candidate) continue;
        if (candidate.includes('elf')) return pools['elf'];
        if (candidate.includes('orc') && pools['black-orc']) return pools['black-orc'];
        if (pools[candidate]) return pools[candidate];
      }
      return ['Arin Vale', 'Kellen Ridge', 'Mara Kest', 'Tamsin Grey', 'Rook Ell', 'Perrin Vale', 'Lysa Crow', 'Taran Vey', 'Silas Thorn', 'Rhea Locke'];
    }

    function generatePlayerNames(teamKey, rosterName, baseName, count, seedSalt, globalUsed) {
      const pool = [...new Set(getNamePool(teamKey, rosterName))];
      const rng = seededRandom(`${teamKey}|${baseName}|${seedSalt}`);
      const syllA = ['ar', 'bel', 'cor', 'dra', 'el', 'far', 'gal', 'hal', 'is', 'jor', 'kal', 'lor', 'mir', 'nor', 'or', 'per', 'quil', 'ron', 'sil', 'tor', 'ur', 'vor', 'wyn', 'zan'];
      const syllB = ['en', 'ion', 'as', 'eth', 'ian', 'or', 'us', 'iel', 'or', 'ak', 'os', 'ir', 'eth', 'ym', 'as', 'yn', 'or', 'ath', 'el', 'or'];
      const names = [];
      const used = globalUsed || new Set();

      const synthName = () => {
        let attempt = 0;
        while (attempt < 200) {
          const part1 = syllA[Math.floor(rng() * syllA.length) % syllA.length];
          const part2 = syllB[Math.floor(rng() * syllB.length) % syllB.length];
          const composed = (part1 + part2).replace(/(^\w)/, c => c.toUpperCase());
          if (!used.has(composed) && !pool.includes(composed)) return composed;
          attempt += 1;
        }
        const fallback = `Name${Math.floor(rng() * 1_000_000)}`;
        return used.has(fallback) ? `${fallback}X` : fallback;
      };

      while (pool.length < 16) {
        const candidate = synthName();
        if (!pool.includes(candidate)) pool.push(candidate);
      }

      for (let i = 0; i < count; i++) {
        let candidate = null;
        let attempts = 0;
        while (attempts < 200 && !candidate) {
          const pick = pool[Math.floor(rng() * pool.length) % pool.length];
          if (!used.has(pick)) {
            candidate = pick;
            break;
          }
          attempts += 1;
        }
        if (!candidate) {
          candidate = synthName();
        }
        used.add(candidate);
        names.push(candidate);
      }
      return names;
    }

    function getSkillOptions(info) {
      const cats = new Set();
      (info.primary || '').split('').forEach(c => cats.add(c));
      (info.secondary || '').split('').forEach(c => cats.add(c));
      const opts = [];
      cats.forEach(c => {
        (skillCatalog[c] || []).forEach(skill => {
          opts.push({ cat: c, name: skill });
        });
      });
      return opts;
    }

    function getAddedSkills(teamKey, rank, playerKey) {
      return addedSkillsStore[teamKey]?.[rank]?.[playerKey] || [];
    }

    function addSkill(teamKey, rank, playerKey, skillName) {
      if (!skillName) return;
      addedSkillsStore[teamKey] = addedSkillsStore[teamKey] || {};
      addedSkillsStore[teamKey][rank] = addedSkillsStore[teamKey][rank] || {};
      addedSkillsStore[teamKey][rank][playerKey] = addedSkillsStore[teamKey][rank][playerKey] || [];
      const list = addedSkillsStore[teamKey][rank][playerKey];
      if (!list.includes(skillName)) list.push(skillName);
      markDetailDirty();
    }

    function removeSkill(teamKey, rank, playerKey, skillName) {
      const list = addedSkillsStore[teamKey]?.[rank]?.[playerKey];
      if (!list) return;
      const idx = list.indexOf(skillName);
      if (idx >= 0) list.splice(idx, 1);
      markDetailDirty();
    }

    function renderAddedSkillsPills(container, teamKey, rank, playerKey) {
      const skills = getAddedSkills(teamKey, rank, playerKey);
      container.innerHTML = skills.length
        ? skills.map(s => `<span class="pill" data-skill="${s}">${s} <button type="button" class="icon-btn secondary skill-remove" data-skill="${s}" style="padding:2px 6px;min-width:0;">×</button></span>`).join(' ')
        : '<span class="muted">-</span>';
    }

    function markDetailDirty() {
      lastDetailContext.dirty = true;
    }

    function wireSkillControls(root) {
      root.querySelectorAll('.skill-select').forEach(sel => {
        sel.addEventListener('change', () => {
          const skill = sel.value;
          if (!skill) return;
          const teamKey = sel.dataset.team;
          const rank = sel.dataset.rank;
          const playerKey = sel.dataset.player;
          addSkill(teamKey, rank, playerKey, skill);
          const pillBox = root.querySelector(`.added-skills[data-player="${playerKey}"][data-rank="${rank}"][data-team="${teamKey}"]`);
          if (pillBox) renderAddedSkillsPills(pillBox, teamKey, rank, playerKey);
          sel.value = '';
        });
      });
      root.querySelectorAll('.added-skills').forEach(box => {
        box.addEventListener('click', (evt) => {
          const btn = evt.target.closest('.skill-remove');
          if (!btn) return;
          const skill = btn.dataset.skill;
          const teamKey = box.dataset.team;
          const rank = box.dataset.rank;
          const playerKey = box.dataset.player;
          removeSkill(teamKey, rank, playerKey, skill);
          renderAddedSkillsPills(box, teamKey, rank, playerKey);
        });
      });
    }

    function hideDetailModal() {
      detailModal.style.display = 'none';
    }

    function showDetailModal(html, title) {
      lastDetailHtml = html;
      lastDetailTitle = title || 'Roster details';
      detailTitle.textContent = lastDetailTitle;
      detailContent.innerHTML = html;
      detailModal.style.display = 'flex';
      markDetailDirty(); // force recompute before export to include latest edits
    }

    function exportDetailPdf() {
      if (!lastDetailHtml || !lastDetailContext.teamKey) {
        alert('No roster details to export yet.');
        return;
      }
      try {
        const ctx = lastDetailContext;
        const settingsCopy = ctx.settings ? JSON.parse(JSON.stringify(ctx.settings)) : null;
        const comboCopy = ctx.combo ? JSON.parse(JSON.stringify(ctx.combo)) : null;
        const rebuilt = ctx.detailed
          ? buildRosterDetailsHtml(ctx.teamKey, ctx.teamName, settingsCopy, comboCopy, ctx.rank, ctx.teamTitle)
          : buildSimpleRosterDetailsHtml(ctx.teamKey, ctx.teamName, settingsCopy, comboCopy, ctx.rank, ctx.teamTitle);
        lastDetailHtml = rebuilt;
        detailContent.innerHTML = rebuilt;
      } catch (err) {
        console.error('Failed to rebuild detail view before export', err);
      }
      const styles = document.querySelector('style')?.innerHTML || '';
      const printable = `
        <!doctype html>
        <html>
          <head>
            <title>${lastDetailTitle}</title>
            <style>
              @page { size: A4 landscape; margin: 6mm; }
              html, body { width: 100%; height: 100%; }
              body { font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif; padding: 6mm; color: #111827; }
              h3 { margin: 0 0 6px 0; font-size: 15px; }
              table { width: 100%; border-collapse: collapse; margin-top: 6px; page-break-inside: avoid; table-layout: fixed; }
              th, td { padding: 2px 3px; border: 1px solid #d1d5db; font-size: 8.5px; text-align: left; word-break: break-word; }
              th.w-narrow, td.w-narrow { width: 4%; text-align: center; }
              th.w-narrow-stat, td.w-narrow-stat { width: 4.5%; text-align: center; }
              th.skills-wide, td.skills-wide { width: 28%; }
              th.cost-col, td.cost-col { width: 8%; text-align: center; }
              .web-only { display: table-cell; }
              .print-only { display: none; }
              @media print {
                .web-only { display: none !important; }
                .print-only { display: table-cell !important; }
              }
              th { background: #f3f4f6; text-transform: uppercase; letter-spacing: 0.2px; }
              .muted { color: #6b7280; font-size: 9px; }
              .pill { display: inline-block; padding: 1px 6px; border-radius: 999px; background: #e0f2fe; margin-right: 3px; margin-bottom: 3px; font-size: 9px; }
              button, select, .icon-btn { display: none !important; }
              ${styles}
            </style>
          </head>
          <body>
            ${lastDetailHtml}
            <div style="position: fixed; bottom: 6px; right: 10px; text-align: right; font-size: 9px; color: #6b7280;">
              Every TV. Every combo. Every winning roster. Created with RosterLab.
            </div>
          </body>
        </html>`;
      const iframe = document.createElement('iframe');
      iframe.style.position = 'fixed';
      iframe.style.right = '0';
      iframe.style.bottom = '0';
      iframe.style.width = '0';
      iframe.style.height = '0';
      iframe.style.border = '0';
      document.body.appendChild(iframe);
      const doc = iframe.contentWindow.document;
      doc.open();
      doc.write(printable);
      doc.close();
      iframe.onload = () => {
        try {
          iframe.contentWindow.focus();
          iframe.contentWindow.print();
        } catch (err) {
          console.error('Print failed', err);
          alert('Could not trigger print. Please try again.');
        }
        setTimeout(() => iframe.remove(), 1000);
      };
    }

    function applyStepper(input) {
      if (!input || input.dataset.stepper === '1') return;
      input.dataset.stepper = '1';
      const wrapper = document.createElement('div');
      wrapper.className = 'stepper';
      const dec = document.createElement('button');
      dec.type = 'button';
      dec.className = 'stepper-btn';
      dec.textContent = '-';
      const inc = document.createElement('button');
      inc.type = 'button';
      inc.className = 'stepper-btn';
      inc.textContent = '+';
      const parent = input.parentNode;
      parent.insertBefore(wrapper, input);
      wrapper.appendChild(dec);
      wrapper.appendChild(input);
      wrapper.appendChild(inc);

      const stepVal = Math.abs(Number(input.step) || 1) || 1;
      const toNum = (val) => {
        const parsed = Number(val);
        return Number.isNaN(parsed) ? 0 : parsed;
      };
      const clamp = (val) => {
        const min = input.min === '' || input.min === undefined ? -Infinity : Number(input.min);
        const max = input.max === '' || input.max === undefined ? Infinity : Number(input.max);
        return Math.max(min, Math.min(max, val));
      };
      const syncDisabled = () => {
        const disabled = input.disabled;
        dec.disabled = disabled;
        inc.disabled = disabled;
        wrapper.classList.toggle('stepper-disabled', disabled);
      };
      const adjust = (delta) => {
        const base = input.value === '' ? 0 : toNum(input.value);
        input.value = String(clamp(base + delta));
        input.dispatchEvent(new Event('input', { bubbles: true }));
        input.dispatchEvent(new Event('change', { bubbles: true }));
      };

      dec.addEventListener('click', () => adjust(-stepVal));
      inc.addEventListener('click', () => adjust(stepVal));
      syncDisabled();
      new MutationObserver(syncDisabled).observe(input, { attributes: true, attributeFilter: ['disabled'] });
    }

    function buildPositions(team, starNames, maxStars, bribes, riotousRookies, apothecaryCount) {
      const base = (team.positions || []).map(pos => {
        const copy = { ...pos };
        if ((copy.name || '').toLowerCase() === 'apothecary' && !copy.role) {
          copy.role = 'apothecary';
        }
        return copy;
      });
      if (apothecaryCount !== undefined) {
        base.forEach(pos => {
          if ((pos.name || '').toLowerCase() === 'apothecary') {
            const currentMax = Number(pos.max ?? apothecaryCount);
            pos.max = Math.min(currentMax, apothecaryCount);
          }
        });
      }
      const stars = (team.starPlayers || [])
        .filter(sp => starNames.map(s => s.toLowerCase()).includes(sp.name.toLowerCase()))
        .slice(0, maxStars)
        .map(sp => ({ name: sp.name, cost: sp.cost, max: 1, type: 'player', role: 'star' }));
      const bribeInfo = bribes && bribes > 0 ? getBribeInfo(team) : null;
      const bribe = bribeInfo ? [{ name: 'Bribe', cost: bribeInfo.cost, max: bribes, type: 'extra', role: 'bribe' }] : [];
      const rookieInfo = riotousRookies && riotousRookies > 0 ? getRiotousRookiesInfo(team) : null;
      const rookies = rookieInfo ? [{
        name: 'Riotous Rookies',
        cost: rookieInfo.cost,
        max: riotousRookies,
        type: 'extra',
        role: 'riotous-rookies',
      }] : [];
      return [...base, ...stars, ...bribe, ...rookies];
    }

    function collectSettings() {
      if (!Object.keys(rosters).length) throw new Error('Rosters not loaded yet.');
      const tv = Number(document.getElementById('tv').value);
      const minPlayers = Number(document.getElementById('minPlayers').value);
      const maxPlayers = Number(document.getElementById('maxPlayers').value);
      const maxResults = Number(document.getElementById('maxResults').value || 5);
      const sort = document.getElementById('sort').value;
      const rerollVal = document.getElementById('rerolls').value;
      const team = document.getElementById('team').value;
      const stars = Array.from(new Set([starSelect1.value, starSelect2.value].filter(Boolean)));
      const bribesVal = document.getElementById('bribes').value;
      const apothecaryVal = document.getElementById('apothecary').value;
      const rookiesVal = document.getElementById('riotousRookies').value;
      const requiredExtras = [];
      const positionalRequired = [];
      positionalList.querySelectorAll('input[type="number"]').forEach(input => {
        const name = input.dataset.name;
        const cnt = Number(input.value || 0);
        if (name && cnt > 0) positionalRequired.push({ name: name.toLowerCase(), count: cnt });
      });

      if (!team) throw new Error('Please select a team.');
      if (!tv || tv <= 0) throw new Error('Provide a positive TV in thousands.');
      if (maxPlayers < minPlayers) throw new Error('Max players must be >= min players.');
      const rerolls = rerollVal === '' ? undefined : Number(rerollVal);
      if (rerolls !== undefined && (Number.isNaN(rerolls) || rerolls < 0)) {
        throw new Error('Rerolls must be a non-negative number.');
      }
      const bribeInfo = getBribeInfo(team);
      const bribes = bribesVal === '' ? undefined : Number(bribesVal);
      if (bribes !== undefined) {
        if (Number.isNaN(bribes) || bribes < 0) throw new Error('Bribes must be non-negative.');
        if (bribeInfo && bribes > bribeInfo.max) throw new Error(`Bribes cannot exceed ${bribeInfo.max}.`);
        if (!bribeInfo && bribes > 0) throw new Error('Bribes not available for this team.');
      }
      const apothecaryInfo = getApothecaryInfo(team);
      const apothecary = apothecaryVal === '' ? undefined : Number(apothecaryVal);
      if (apothecary !== undefined) {
        if (Number.isNaN(apothecary) || apothecary < 0) throw new Error('Apothecary must be non-negative.');
        if (!apothecaryInfo) throw new Error('Apothecary not available for this team.');
        if (apothecaryInfo && apothecary > apothecaryInfo.max) throw new Error(`Apothecary cannot exceed ${apothecaryInfo.max}.`);
      }
      const rookiesInfo = getRiotousRookiesInfo(team);
      const riotousRookies = rookiesVal === '' ? 0 : Number(rookiesVal);
      if (Number.isNaN(riotousRookies) || riotousRookies < 0) throw new Error('Riotous rookies must be non-negative.');
      if (rookiesInfo && riotousRookies > rookiesInfo.max) throw new Error(`Riotous rookies cannot exceed ${rookiesInfo.max}.`);
      if (!rookiesInfo && riotousRookies > 0) throw new Error('Riotous rookies not available for this team.');

      const combinedRequired = [...positionalRequired];
      if (stars.length > 2) throw new Error('Select at most 2 stars.');
      const availableStarNames = (rosters[team].starPlayers || []).map(s => s.name.toLowerCase());
      const missingStars = stars.filter(s => !availableStarNames.includes(s.toLowerCase()));
      if (missingStars.length) throw new Error(`Unknown star(s): ${missingStars.join(', ')}`);
      if (bribes !== undefined && bribes > 0) {
        requiredExtras.push({ name: 'bribe', count: bribes });
      }
      if (apothecary !== undefined && apothecary > 0) {
        requiredExtras.push({ name: 'apothecary', count: apothecary });
      }

      return {
        team,
        tv,
        minPlayers,
        maxPlayers,
        maxResults,
        sort,
        rerolls,
        required: combinedRequired,
        requiredExtras,
        requireMode: 'all',
        requireExtraMode: 'all',
        stars,
        bribes,
        apothecary,
        riotousRookies,
        maxStars: 2,
      };
    }

    function renderResults(teamName, settings, combos) {
      const list = Array.isArray(combos) ? combos : [];
      const effectivePageSize = Number(settings.maxResults) > 0 ? Number(settings.maxResults) : (pageSize || 5);
      pageSize = effectivePageSize;
      const totalPages = list.length ? Math.ceil(list.length / effectivePageSize) : 1;
      currentPage = Math.min(Math.max(1, currentPage), totalPages);
      const container = document.getElementById('results');
      container.innerHTML = '';
      const generatedTeamName = generateTeamName(settings.team, teamName, `${settings.tv}-${list.length || 0}`);
      const header = document.createElement('div');
      header.className = 'muted';
      header.textContent = `Team: ${teamName} - ${generatedTeamName} • Target TV: ${settings.tv}k • Results: ${list.length || 0}`;
      container.appendChild(header);

      const pageInfo = document.getElementById('pageInfo');
      const prevBtn = document.getElementById('prevPage');
      const nextBtn = document.getElementById('nextPage');
      pageInfo.textContent = list.length ? `Page ${currentPage} of ${totalPages}` : '';
      prevBtn.disabled = currentPage <= 1 || !list.length;
      nextBtn.disabled = currentPage >= totalPages || !list.length;

      if (!list.length) {
        const none = document.createElement('div');
        none.className = 'error';
        const stars = settings.stars && settings.stars.length ? ` (selected stars required: ${settings.stars.join(', ')})` : '';
        none.textContent = `No combinations found under the given constraints${stars ? '; try raising TV or lowering min players so the stars fit' : ''}.`;
        container.appendChild(none);
        return;
      }

      const start = (currentPage - 1) * effectivePageSize;
      const pageItems = list.slice(start, start + effectivePageSize);

      pageItems.forEach((combo, idx) => {
        const card = document.createElement('div');
        card.className = 'result';
        const title = document.createElement('div');
        title.innerHTML = `<strong>#${start + idx + 1}</strong> | Cost: ${combo.cost}k | Players: ${combo.totalPlayers}`;
        card.appendChild(title);

        const pills = document.createElement('div');
        pills.style.marginTop = '6px';
        pills.innerHTML = `
          <span class="pill">positionals: ${combo.positionals}</span>
          <span class="pill">linemen: ${combo.linemen}</span>
          <span class="pill">rerolls: ${combo.rerolls}</span>
        `;
        card.appendChild(pills);

        const list = document.createElement('ul');
        list.className = 'list';
        combo.players
          .filter(p => p.count > 0)
          .forEach(p => {
            const li = document.createElement('li');
            const extraBodies = p.addsPlayers ? ` (+${p.addsPlayers * p.count} players)` : '';
            li.textContent = `${p.count} x ${p.name} @ ${p.cost}k${extraBodies}`;
            list.appendChild(li);
          });
        card.appendChild(list);

        const copyBtn = document.createElement('button');
        copyBtn.type = 'button';
        copyBtn.className = 'icon-btn secondary';
        copyBtn.setAttribute('aria-label', 'Copy roster to clipboard');
        copyBtn.style.marginTop = '8px';
        copyBtn.textContent = '📋';
        copyBtn.addEventListener('click', () => copyRosterToClipboard(teamName, settings, combo, start + idx + 1));
        const detailBtn = document.createElement('button');
        detailBtn.type = 'button';
        detailBtn.className = 'icon-btn secondary';
        detailBtn.setAttribute('aria-label', 'View full roster details');
        detailBtn.style.marginTop = '8px';
        detailBtn.textContent = '🗒 Details';
        detailBtn.addEventListener('click', () => showRosterDetails(settings.team, teamName, settings, combo, start + idx + 1));
        const actions = document.createElement('div');
        actions.className = 'row';
        actions.style.gap = '8px';
        actions.style.flexWrap = 'wrap';
        actions.appendChild(copyBtn);
        actions.appendChild(detailBtn);
        card.appendChild(actions);

        container.appendChild(card);
      });

    }

    function findPlayerDetails(teamKey, playerName) {
      const roster = rosters[teamKey];
      if (!roster) return null;
      const norm = (playerName || '').toLowerCase();
      const sanitized = sanitizeStarName(playerName).toLowerCase();
      const pos = (roster.positions || []).find(p => (p.name || '').toLowerCase() === norm);
      if (pos) return pos;
      const star = (roster.starPlayers || []).find(sp => sanitizeStarName(sp.name).toLowerCase() === sanitized);
      return star || null;
    }

    function fmtStat(value, withPlus = false) {
      if (value === undefined || value === null || value === '') return '-';
      return withPlus ? `${value}+` : String(value);
    }

    function buildSimpleRosterDetailsHtml(teamKey, teamName, settings, combo, rank, teamTitleText) {
      const roster = rosters[teamKey] || {};
      const players = combo.players.filter(p => (p.type ?? 'player') === 'player' && p.count > 0);
      const extras = combo.players.filter(p => (p.type ?? 'player') === 'extra' && p.count > 0);
      const leagues = (roster.leagues || []).join(', ') || '—';
      const specialRules = (roster.specialRules || []).join(', ') || 'None';
      const rerollInfo = roster.rerolls || null;
      const apothecaryInfo = roster.hasApothecary === undefined ? 'Unknown' : (roster.hasApothecary ? 'Yes' : 'No');
      const playerRows = players.map(p => {
        const info = findPlayerDetails(teamKey, p.name) || {};
        const skills = (info.skills || []).join(', ') || '—';
        const subtotal = p.cost * p.count;
        return `
          <tr>
            <td>${p.count} x ${p.name}</td>
            <td class="text-center">${fmtStat(info.ma)}</td>
            <td class="text-center">${fmtStat(info.st)}</td>
            <td class="text-center">${fmtStat(info.ag, true)}</td>
            <td class="text-center">${fmtStat(info.pa, true)}</td>
            <td class="text-center">${fmtStat(info.av, true)}</td>
            <td>${skills}</td>
            <td class="text-center">${info.primary || '—'}</td>
            <td class="text-center">${info.secondary || '—'}</td>
            <td class="text-center">${p.cost}k</td>
            <td class="text-center">${subtotal}k</td>
          </tr>`;
      }).join('');
      const extrasRows = extras.length
        ? extras.map(ex => `<tr><td>${ex.count} x ${ex.name}</td><td class="text-center">${ex.cost}k</td><td class="text-center">${ex.cost * ex.count}k</td></tr>`).join('')
        : '<tr><td colspan="3" class="muted">No inducements or sideline extras selected.</td></tr>';
      const rerollPos = (roster.positions || []).find(p => (p.name || '').toLowerCase() === 'reroll');
      const rerollText = rerollInfo || rerollPos
        ? `Re-rolls: 0-${(rerollInfo?.max ?? rerollPos?.max ?? '?')} @ ${(rerollInfo?.cost ?? rerollPos?.cost ?? '?')}k`
        : 'Re-roll info unavailable';
      return `
        <h3 style="margin: 0 0 6px 0;">${teamTitleText || teamName}</h3>
        <div class="muted" style="margin-bottom: 6px;">
          #${rank} • ${teamName} • Players: ${combo.totalPlayers} • Cost: ${combo.cost}k (target TV ${settings.tv}k)
        </div>
        <table>
          <thead>
            <tr>
              <th>Position</th><th class="text-center">MA</th><th class="text-center">ST</th><th class="text-center">AG</th><th class="text-center">PA</th><th class="text-center">AV</th><th>Skills</th><th class="text-center">Primary</th><th class="text-center">Secondary</th><th class="text-center">Cost</th><th class="text-center">Total</th>
            </tr>
          </thead>
          <tbody>${playerRows || '<tr><td colspan="11" class="muted">No players in this roster.</td></tr>'}</tbody>
        </table>
        <h4 style="margin: 12px 0 4px 0;">Inducements & Extras</h4>
        <table>
          <thead><tr><th>Name</th><th class="text-center">Cost</th><th class="text-center">Total</th></tr></thead>
          <tbody>${extrasRows}</tbody>
        </table>
        <div class="muted" style="margin-top: 10px;">
          ${rerollText} • Apothecary: ${apothecaryInfo} • Leagues: ${leagues} • Special rules: ${specialRules}
        </div>
      `;
    }

    function buildRosterDetailsHtml(teamKey, teamName, settings, combo, rank, teamTitleText) {
      const roster = rosters[teamKey] || {};
      const players = combo.players.filter(p => (p.type ?? 'player') === 'player' && p.count > 0);
      const extras = combo.players.filter(p => (p.type ?? 'player') === 'extra' && p.count > 0);
      const leagues = (roster.leagues || []).join(', ') || '—';
      const specialRules = (roster.specialRules || []).join(', ') || 'None';
      const rerollInfo = roster.rerolls || null;
      const apothecaryInfo = roster.hasApothecary === undefined ? 'Unknown' : (roster.hasApothecary ? 'Yes' : 'No');
      const usedNames = new Set();
      const playerRows = [];
      players.forEach(p => {
        const info = findPlayerDetails(teamKey, p.name) || {};
        const skills = (info.skills || []).join(', ') || '—';
        const names = generatePlayerNames(teamKey, roster.name || teamName, p.name, p.count, `${rank}-${settings.tv}-${p.name}`, usedNames);
        names.forEach((playerName, idx) => {
          const playerKey = `${teamKey}|${rank}|${playerName}`;
          const added = getAddedSkills(teamKey, rank, playerKey);
          const options = getSkillOptions(info);
          const primaries = options.filter(o => (info.primary || '').includes(o.cat));
          const secondaries = options.filter(o => (info.secondary || '').includes(o.cat) && !(info.primary || '').includes(o.cat));
          const optionsHtml = [
            '<option value="">Add skill...</option>',
            ...primaries.map(o => `<option value="${o.name}">${o.name} (${o.cat} - primary)</option>`),
            '<option disabled>────────</option>',
            ...secondaries.map(o => `<option value="${o.name}">${o.name} (${o.cat} - secondary)</option>`),
          ].join('');
          const addedPills = added.length
            ? added.map(s => `<span class="pill" data-skill="${s}">${s} <button type="button" class="icon-btn secondary skill-remove" data-skill="${s}" style="padding:2px 6px;min-width:0;">×</button></span>`).join(' ')
            : '<span class="muted">-</span>';
          const addedText = added.length ? added.join(', ') : '-';
          playerRows.push(`
            <tr>
              <td class="text-center">${playerRows.length + 1}</td>
              <td>${playerName}</td>
              <td>${p.name}</td>
              <td class="text-center">${fmtStat(info.ma)}</td>
              <td class="text-center">${fmtStat(info.st)}</td>
              <td class="text-center">${fmtStat(info.ag, true)}</td>
              <td class="text-center">${fmtStat(info.pa, true)}</td>
              <td class="text-center">${fmtStat(info.av, true)}</td>
              <td class="skills-wide web-only">${skills}</td>
              <td class="text-center web-only">${info.primary || '—'}</td>
              <td class="text-center web-only">${info.secondary || '—'}</td>
              <td class="skills-wide">${skills}</td>
              <td class="web-only">
                <div class="added-skills" data-team="${teamKey}" data-rank="${rank}" data-player="${playerKey}">${addedPills}</div>
                <select class="skill-select" data-team="${teamKey}" data-rank="${rank}" data-player="${playerKey}" style="margin-top: 6px;">${optionsHtml}</select>
              </td>
             <td class="skills-wide print-only">${addedText}</td>
              <td class="text-center w-narrow cost-col">${p.cost}k</td>
            </tr>`);
        });
      });
      const playerRowsHtml = playerRows.join('');
      const extrasRows = extras.length
        ? extras.map(ex => `<tr><td>${ex.count} x ${ex.name}</td><td class="text-center">${ex.cost}k</td><td class="text-center">${ex.cost * ex.count}k</td></tr>`).join('')
        : '<tr><td colspan="3" class="muted">No inducements or sideline extras selected.</td></tr>';

      const rerollPos = (roster.positions || []).find(p => (p.name || '').toLowerCase() === 'reroll');
      const rerollText = rerollInfo || rerollPos
        ? `Re-rolls: 0-${(rerollInfo?.max ?? rerollPos?.max ?? '?')} @ ${(rerollInfo?.cost ?? rerollPos?.cost ?? '?')}k`
        : 'Re-roll info unavailable';
      return `
        <h3 style="margin: 0 0 6px 0;">${teamTitleText || teamName}</h3>
        <div class="muted" style="margin-bottom: 6px;">
          #${rank} • ${teamName} • Players: ${combo.totalPlayers} • Cost: ${combo.cost}k (target TV ${settings.tv}k)
        </div>
        <table>
          <thead>
            <tr>
              <th class="w-narrow">#</th><th>Name</th><th>Position</th><th class="w-narrow-stat">MA</th><th class="w-narrow-stat">ST</th><th class="w-narrow-stat">AG</th><th class="w-narrow-stat">PA</th><th class="w-narrow-stat">AV</th><th class="skills-wide web-only">Skills</th><th class="text-center web-only">Primary</th><th class="text-center web-only">Secondary</th><th class="skills-wide print-only">Skills</th><th class="skills-wide print-only">Added Skills</th><th class="text-center w-narrow cost-col">Cost</th>
            </tr>
          </thead>
          <tbody>${playerRowsHtml || '<tr><td colspan="14" class="muted">No players in this roster.</td></tr>'}</tbody>
        </table>
        <h4 style="margin: 12px 0 4px 0;">Inducements & Extras</h4>
        <table>
          <thead><tr><th>Name</th><th class="text-center">Cost</th><th class="text-center">Total</th></tr></thead>
          <tbody>${extrasRows}</tbody>
        </table>
        <div class="muted" style="margin-top: 10px;">
          ${rerollText} • Apothecary: ${apothecaryInfo} • Leagues: ${leagues} • Special rules: ${specialRules}
        </div>
      `;
    }

    function showRosterDetails(teamKey, teamName, settings, combo, rank) {
      const generatedName = generateTeamName(teamKey, teamName, `${settings.tv}-${rank}`);
      const teamTitle = `${teamName} - ${generatedName}`;
      lastDetailContext.teamKey = teamKey;
      lastDetailContext.teamName = teamName;
      lastDetailContext.settings = JSON.parse(JSON.stringify(settings));
      lastDetailContext.combo = JSON.parse(JSON.stringify(combo));
      lastDetailContext.rank = rank;
      lastDetailContext.teamTitle = teamTitle;
      lastDetailContext.detailed = Boolean(detailedViewToggle?.checked);
      lastDetailContext.dirty = false;
      const html = detailedViewToggle?.checked
        ? buildRosterDetailsHtml(teamKey, teamName, settings, combo, rank, teamTitle)
        : buildSimpleRosterDetailsHtml(teamKey, teamName, settings, combo, rank, teamTitle);
      showDetailModal(html, `${teamTitle} (roster #${rank})`);
      wireSkillControls(detailContent);
    }

    async function copyRosterToClipboard(teamName, settings, combo, rank) {
      const lines = combo.players
        .filter(p => p.count > 0)
        .map(p => {
          const extraBodies = p.addsPlayers ? ` (+${p.addsPlayers * p.count} players)` : '';
          return `${p.count} x ${p.name} @ ${p.cost}k${extraBodies}`;
        });
      const header = `#${rank} | ${teamName}\nCost: ${combo.cost}k | Players: ${combo.totalPlayers}\nTV: ${settings.tv}k`;
      const text = [header, ...lines].join('\n');
      try {
        await navigator.clipboard.writeText(text);
      } catch (err) {
        const fallback = legacyCopy(text);
        if (!fallback) {
          console.error('Clipboard copy failed', err);
          alert('Could not copy roster to clipboard. Please copy manually.');
        }
      }
    }

    function legacyCopy(text) {
      try {
        const ta = document.createElement('textarea');
        ta.value = text;
        ta.style.position = 'fixed';
        ta.style.top = '-1000px';
        ta.style.left = '-1000px';
        document.body.appendChild(ta);
        ta.focus();
        ta.select();
        const ok = document.execCommand('copy');
        document.body.removeChild(ta);
        return ok;
      } catch (err) {
        console.error('Legacy copy failed', err);
        return false;
      }
    }

    function sanitizeStarName(name) {
      if (!name) return '';
      // Strip affiliation suffixes the BBTC UI does not show.
      return name.replace(/\s+(Old World Classic|Lustrian Superleague|Badlands Brawl|Worlds Edge Superleague|Sylvanian Spotlight|Elven Kingdoms|Underworld Challenge|Halfling Thimble Cup|Favoured of [^,]+)$/i, '').trim();
    }

    function buildBbtcPayload(teamKey, teamName, settings, combo, rank) {
      const players = combo.players
        .filter(p => (p.type ?? 'player') === 'player' && p.count > 0)
        .map(p => ({ name: sanitizeStarName(p.name), count: p.count }));
      const extras = combo.players
        .filter(p => (p.type ?? 'player') === 'extra' && p.count > 0)
        .map(p => ({ name: p.name, role: p.role || '', count: p.count }));
      const rerollExtra = extras.find(e => (e.name || '').toLowerCase().includes('reroll'));
      const bribesExtra = extras.find(e => (e.role === 'bribe') || (e.name || '').toLowerCase().includes('bribe'));
      const rookiesExtra = extras.find(e => (e.role === 'riotous-rookies') || (e.name || '').toLowerCase().includes('riotous rookies'));
      const apothecaryExtra = extras.find(e => (e.role === 'apothecary') || (e.name || '').toLowerCase().includes('apothecary'));
      return {
        teamSlug: teamKey,
        teamName,
        rank,
        players,
        rerolls: combo.rerolls ?? rerollExtra?.count ?? 0,
        bribes: bribesExtra?.count ?? 0,
        apothecary: apothecaryExtra?.count ?? 0,
        riotousRookies: rookiesExtra?.count ?? 0,
      };
    }

    function buildBbtcInjectionScript(payload) {
      const injector = (payload) => {
        const normalize = (str) => (str || '').toLowerCase().replace(/[^a-z0-9+ ]+/g, ' ').replace(/\s+/g, ' ').trim();
        const endpoint = (typeof window.getAjaxEndpoint === 'function') ? window.getAjaxEndpoint() : '/ajax';
        const log = (msg) => console.log(`[RosterLab→BBTC] ${msg}`);
        const requiredPath = `/team/bb2025/${payload.teamSlug}`;
        if (!location.pathname.includes(requiredPath)) {
          alert(`Open https://bbtc.pl${requiredPath} first, then paste again.`);
          log(`Please navigate to ${requiredPath} before importing.`);
          return;
        }
        if (typeof window.CallAjax !== 'function') {
          alert('BBTC scripts not ready yet. Wait for the page to finish loading, then paste again.');
          return;
        }

        const missing = [];
        const selects = Array.from(document.querySelectorAll('#playersTable select.selectpicker'));
        if (!selects.length) {
          alert('Could not find the players table on BBTC.');
          return;
        }

        const optionMap = {};
        selects[0].querySelectorAll('option').forEach(opt => {
          if (!opt.value) return;
          optionMap[normalize(opt.textContent)] = opt.value;
        });

        const findPlayerId = (name) => {
          const target = normalize(name);
          if (optionMap[target]) return optionMap[target];
          const fuzzy = Object.entries(optionMap).find(([optName]) => optName.includes(target) || target.includes(optName));
          return fuzzy ? fuzzy[1] : null;
        };

        const queueDelete = () => {
          selects.forEach(sel => {
            const currentVal = sel.value;
            if (!currentVal || currentVal === '0') return;
            const position = Number(sel.id.replace('player-select-', ''));
            const data = { operation: 'delete-player', app: 'team', action: 'create', data: { position }, busy: { area: 'player-select', id: sel.id }, previous: { area: 'player-select', id: sel.id, value: currentVal } };
            window.CallAjax(endpoint, data, window.refreshPlayerRow);
          });
        };

        const queuePlayers = () => {
          let slot = 1;
          payload.players.forEach(player => {
            const playerId = findPlayerId(player.name);
            if (!playerId) {
              missing.push(`Player not found: ${player.name}`);
              return;
            }
            for (let i = 0; i < player.count; i++) {
              if (slot > selects.length) {
                missing.push(`Not enough slots for ${player.name}`);
                return;
              }
              const data = {
                operation: 'add-player',
                app: 'team',
                action: 'create',
                data: { position: slot, playerId },
                busy: { area: 'player-select', id: `player-select-${slot}` },
                previous: { area: 'player-select', id: `player-select-${slot}`, value: '0' },
              };
              window.CallAjax(endpoint, data, window.refreshPlayerRow);
              slot += 1;
            }
          });
        };

        const setAreaQuantity = (tableSelector, targetName, value, fallbackArea) => {
          if (value === undefined || value === null) return;
          const normTarget = normalize(targetName);
          const row = Array.from(document.querySelectorAll(`${tableSelector} tbody tr`)).find(tr => normalize(tr.textContent || '').includes(normTarget));
          if (!row) {
            if (value > 0) missing.push(`Could not find row for ${targetName}`);
            return;
          }
          const area = row.closest('[data-bb-area]')?.getAttribute('data-bb-area') || fallbackArea;
          const id = row.getAttribute('data-bb-id');
          const data = { operation: `update-${area}-quantity`, app: 'team', action: 'create', data: { id, value, area } };
          window.CallAjax(endpoint, data, window.updateArea);
        };

        queueDelete();
        queuePlayers();
        setAreaQuantity('#sidelineTable', 're-roll', payload.rerolls, 'sideline');
        setAreaQuantity('#sidelineTable', 'apothecary', payload.apothecary, 'sideline');
        setAreaQuantity('#inducementsTable', 'bribe', payload.bribes, 'inducements');
        setAreaQuantity('#inducementsTable', 'riotous rookies', payload.riotousRookies, 'inducements');

        if (missing.length) {
          log(`Completed with notes:\\n- ${missing.join('\\n- ')}`);
          alert(`Imported with notes:\\n${missing.join('\\n')}`);
        } else {
          log(`Queued roster import for ${payload.teamName || payload.teamSlug}. Watch the BBTC page update.`);
        }
      };

      return `(${injector.toString()})(${JSON.stringify(payload)});`;
    }

    async function exportRosterToBbtc(teamKey, teamName, settings, combo, rank) {
      const payload = buildBbtcPayload(teamKey, teamName, settings, combo, rank);
      const script = buildBbtcInjectionScript(payload);
      let copied = false;
      try {
        await navigator.clipboard.writeText(script);
        copied = true;
      } catch (err) {
        copied = legacyCopy(script);
        if (!copied) {
          console.warn('RosterLab BBTC script (copy manually):\n', script);
        }
      }
      const targetUrl = `https://bbtc.pl/team/bb2025/${teamKey}`;
      const consoleHowTo = [
        'On mac: press Cmd+Option+I (Chrome/Firefox/Safari) to open DevTools, then click the Console tab. On Windows/Linux: press Ctrl+Shift+I or F12, then select Console.',
        'Click inside the console prompt (usually a > line), paste the script (Cmd+V / Ctrl+V), and press Enter.',
        'Wait a few seconds while the page updates; watch the console for any “RosterLab→BBTC” messages or missing-player notes.',
        'On mobile: browsers generally block console access; use a desktop/laptop to run the script.',
      ].join('\n');
      const note = (copied
        ? `BBTC fill script copied. Open ${targetUrl}, paste into the browser console, and press Enter to queue the roster.`
        : `Could not copy automatically. Open ${targetUrl} and paste the script shown in the console to import.`) + '\n\n' + consoleHowTo;
      alert(note);
      window.open(targetUrl, '_blank', 'noopener');
    }

    function parseRequirements(str) {
      const pieces = str.split(',');
      const parsed = pieces
        .map(piece => {
          const parts = piece.split(':');
          if (!parts[0]) return null;
          const name = parts[0].trim().toLowerCase();
          const count = parts[1] ? Number(parts[1]) : 1;
          if (!name || Number.isNaN(count) || count <= 0) return null;
          return { name, count };
        })
        .filter(Boolean);
      return parsed.length ? parsed : null;
    }

    function generateCombos(positions, settings) {
      const results = [];
      const path = [];

      function dfs(index, remainingCost, totalPlayers, starCount) {
        if (remainingCost < 0 || totalPlayers > settings.maxPlayers) return;
        if (index >= positions.length || remainingCost === 0) {
          if (totalPlayers < settings.minPlayers || totalPlayers > settings.maxPlayers) return;
          const spent = settings.tv - remainingCost;
          const summary = path.reduce(
            (acc, p) => {
              if (!p.count) return acc;
              const type = p.type ?? 'player';
              const name = (p.name || '').toLowerCase();
              if (type === 'extra') {
                if (name === 'reroll') acc.rerolls += p.count;
                if (name.includes('bribe')) acc.bribes += p.count;
                if (name.includes('apothecary')) acc.apothecary += p.count;
              }
              if (type === 'player') {
                const isLineman = p.role === 'lineman' || name.includes('lineman');
                const isStar = p.role === 'star';
                if (isStar) {
                  acc.stars += p.count;
                  acc.starCounts[name] = (acc.starCounts[name] ?? 0) + p.count;
                }
                if (isLineman) acc.lineman += p.count;
                else acc.positionals += p.count;
              }
              const bigGuyTeams = ['old-world-alliance', 'chaos-chosen', 'chaos-renegade', 'underworld-denizens'];
              if (bigGuyTeams.includes(settings.team)) {
                const isTreeman = name.includes('treeman');
                const isOgre = name === 'ogre';
                const isTroll = name === 'troll';
                const isMinotaur = name === 'minotaur';
                const isRatOgre = name.includes('rat ogre');
                if (isTreeman || isOgre || isTroll || isMinotaur || isRatOgre) acc.bigGuys += p.count;
              }
              if (settings.required && settings.required.length) {
                const req = settings.required.find(r => r.name === name);
                if (req) acc.required[name] = (acc.required[name] ?? 0) + p.count;
              }
              if (settings.requiredExtras && settings.requiredExtras.length) {
                const req = settings.requiredExtras.find(r => r.name === name);
                if (req) acc.requiredExtras[name] = (acc.requiredExtras[name] ?? 0) + p.count;
              }
              return acc;
            },
            { rerolls: 0, bribes: 0, apothecary: 0, positionals: 0, lineman: 0, stars: 0, bigGuys: 0, required: {}, requiredExtras: {}, starCounts: {} }
          );

          const missingRequired = settings.required && settings.required.some(
            r => (summary.required[r.name] ?? 0) < r.count
          );
          const missingRequiredExtras = settings.requiredExtras && settings.requiredExtras.some(
            r => (summary.requiredExtras[r.name] ?? 0) < r.count
          );

          const failsRequiredAny = settings.requireMode === 'any' &&
            settings.required.length > 0 &&
            settings.required.every(r => (summary.required[r.name] ?? 0) < r.count);
          const failsRequiredAll = settings.requireMode === 'all' && missingRequired;

          const failsExtrasAny = settings.requireExtraMode === 'any' &&
            settings.requiredExtras.length > 0 &&
            settings.requiredExtras.every(r => (summary.requiredExtras[r.name] ?? 0) < r.count);
          const failsExtrasAll = settings.requireExtraMode === 'all' && missingRequiredExtras;
          let exceedsBigGuyLimit = false;
          if (settings.team === 'old-world-alliance' || settings.team === 'chaos-chosen') {
            exceedsBigGuyLimit = summary.bigGuys > 1;
          } else if (settings.team === 'chaos-renegade') {
            exceedsBigGuyLimit = summary.bigGuys > 3;
          } else if (settings.team === 'underworld-denizens') {
            exceedsBigGuyLimit = summary.bigGuys > 1;
          }

          if (
            (settings.rerolls !== undefined && summary.rerolls !== settings.rerolls) ||
            settings.stars.some(s => (summary.starCounts[s.toLowerCase()] ?? 0) < 1) ||
            summary.stars > settings.maxStars ||
            failsRequiredAny ||
            failsRequiredAll ||
            failsExtrasAny ||
            failsExtrasAll ||
            exceedsBigGuyLimit
          ) {
            return;
          }

          results.push({
            players: [...path],
            cost: spent,
            totalPlayers,
            rerolls: summary.rerolls,
            bribes: summary.bribes,
            positionals: summary.positionals,
            linemen: summary.lineman,
          });
          return;
        }

        const pos = positions[index];
        const isPlayer = (pos.type ?? 'player') === 'player';
        const isStar = pos.role === 'star';
        const addedPerUnit = isPlayer ? 1 : 0;
        const maxByCost = pos.cost > 0 ? Math.floor(remainingCost / pos.cost) : pos.max;
        const playerRoom = addedPerUnit > 0 ? Math.floor((settings.maxPlayers - totalPlayers) / addedPerUnit) : Number.MAX_SAFE_INTEGER;
        const starRoom = isStar ? settings.maxStars - starCount : Number.MAX_SAFE_INTEGER;
        const maxCount = Math.min(pos.max, maxByCost, playerRoom, starRoom);

        for (let count = 0; count <= maxCount; count++) {
          path.push({ name: pos.name, count, cost: pos.cost, type: pos.type, role: pos.role });
          const nextPlayers = totalPlayers + count * addedPerUnit;
          const nextStars = isStar ? starCount + count : starCount;
          dfs(index + 1, remainingCost - count * pos.cost, nextPlayers, nextStars);
          path.pop();
        }
      }

      dfs(0, settings.tv, 0, 0);

      return results
        .filter(r => r.totalPlayers <= settings.maxPlayers)
        .sort((a, b) => {
          if (settings.sort === 'players') {
            return (
              b.totalPlayers - a.totalPlayers ||
              b.positionals - a.positionals ||
              a.linemen - b.linemen ||
              b.cost - a.cost ||
              b.rerolls - a.rerolls ||
              0
            );
          }
          return (
            b.cost - a.cost ||
            b.totalPlayers - a.totalPlayers ||
            b.positionals - a.positionals ||
            a.linemen - b.linemen ||
            a.bribes - b.bribes ||
            b.rerolls - a.rerolls ||
            0
          );
        });
    }

  </script>
</body>
</html>
