<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>RosterLab</title>
  <link rel="icon" type="image/png" href="wmino.png" />
  <style>
    :root {
      --bg: #0f172a;
      --panel: #111827;
      --accent: #38bdf8;
      --text: #e5e7eb;
      --muted: #9ca3af;
      --border: #1f2937;
      --danger: #f43f5e;
      --success: #22c55e;
      --mono: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      background: radial-gradient(circle at 20% 20%, #0b1224, #0a0f1f 50%, #090d18 100%);
      color: var(--text);
      font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      padding: 24px;
    }
    h1 { margin: 0 0 16px; font-size: 24px; letter-spacing: 0.4px; }
    .card {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 18px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.45);
      max-width: 1100px;
      margin: 0 auto 18px;
    }
    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 12px;
    }
    label {
      display: flex;
      flex-direction: column;
      gap: 6px;
      font-size: 13px;
      color: var(--muted);
    }
    input, select, button, textarea {
      width: 100%;
      padding: 10px 12px;
      background: #0b162c;
      border: 1px solid var(--border);
      border-radius: 10px;
      color: var(--text);
      font-size: 14px;
    }
    textarea { min-height: 44px; resize: vertical; }
    button {
      background: linear-gradient(135deg, #3b82f6, #06b6d4);
      border: none;
      cursor: pointer;
      font-weight: 600;
      transition: transform 120ms ease, box-shadow 120ms ease;
    }
    button:hover { transform: translateY(-1px); box-shadow: 0 8px 20px rgba(56,189,248,0.3); }
    .stepper {
      display: flex;
      align-items: center;
      gap: 8px;
      width: 100%;
    }
    .stepper input[type="number"] {
      flex: 1;
      width: auto;
    }
    .stepper-btn {
      width: 38px;
      padding: 10px 0;
      background: #0b162c;
      border: 1px solid var(--border);
      color: var(--text);
      border-radius: 10px;
      font-weight: 700;
      line-height: 1;
      box-shadow: none;
    }
    .stepper-btn:disabled { opacity: 0.45; cursor: not-allowed; }
    .stepper.stepper-disabled .stepper-btn { opacity: 0.45; cursor: not-allowed; }
    .icon-btn {
      width: auto;
      min-width: 36px;
      padding: 6px 10px;
      font-size: 14px;
      line-height: 1;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
    }
    .icon-btn.secondary {
      background: #0b162c;
      border: 1px solid var(--border);
      box-shadow: none;
    }
    .icon-btn.secondary:hover { box-shadow: none; transform: translateY(-1px); }
    .row {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
      margin-top: 12px;
    }
    .results { margin-top: 10px; }
    .result {
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px;
      margin-top: 10px;
      background: #0c1426;
    }
    .muted { color: var(--muted); font-size: 13px; }
    .pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 8px;
      border-radius: 999px;
      background: rgba(56,189,248,0.15);
      color: var(--text);
      font-size: 12px;
      font-family: var(--mono);
      margin-right: 6px;
    }
    .error {
      color: var(--danger);
      margin-top: 8px;
      font-size: 14px;
    }
    .badge { color: var(--success); font-size: 12px; margin-left: 6px; }
    .list { margin: 6px 0 0 0; padding-left: 16px; }
    code { font-family: var(--mono); }
    @media (max-width: 640px) {
      body { padding: 16px; }
      .card { padding: 14px; }
    }
  </style>
</head>
<body>
  <div class="card">
    <div class="row" style="justify-content: space-between; align-items: center; margin-top: 0;">
      <h1 style="margin: 0; display: inline-flex; align-items: center; gap: 8px;">
        <img src="wmino.png" alt="RosterLab icon" style="width: 28px; height: 28px; border-radius: 6px;" />
        RosterLab v0.2
      </h1>
      <button id="guideToggle" type="button" style="max-width: 160px;">Show guide</button>
    </div>
    <p id="userGuide" class="muted" style="margin-top: 10px; display: none;">Use the tool to pick your team, set your TV (in thousands), choose min/max players, and decide how many results you want per page. You can sort by total cost or by number of players, and even lock in exact rerolls if you like. If you want to force certain choicesâ€”like minimum numbers of positionals, up to two star players, a set number of bribes, or taking an apothecaryâ€”add those too. Hit Generate to see valid roster combinations, then flip through the pages to explore them. If nothing appears, ease your constraints by raising TV, lowering player minimums, or relaxing forced choices. Tweak, regenerate, and experiment until you find the perfect Blood Bowl roster.</p>

    <div class="grid">
      <label>Team
        <select id="team"></select>
      </label>
      <label>TV (in thousands)
        <input type="number" id="tv" value="1000" min="1" step="10" />
      </label>
      <label>Min players
        <input type="number" id="minPlayers" value="11" min="0" />
      </label>
      <label>Max players
        <input type="number" id="maxPlayers" value="16" min="0" />
      </label>
      <label>Max results per page
        <input type="number" id="maxResults" value="5" min="1" />
      </label>
      <label>Sort by
        <select id="sort">
          <option value="cost">Cost (desc)</option>
          <option value="players">Players (desc)</option>
        </select>
      </label>
      <label>Rerolls (exact, optional)
        <input type="number" id="rerolls" placeholder="leave blank" min="0" />
      </label>
      <label>Positionals to force (enter minimums)
        <div id="positionalList"></div>
      </label>
      <label>Bribes (exact, optional)
        <input type="number" id="bribes" value="0" placeholder="leave blank" min="0" />
      </label>
      <label>Apothecary (exact, optional)
        <input type="number" id="apothecary" placeholder="0 or 1, leave blank to skip" min="0" max="1" />
      </label>
      <label id="riotousRookiesField" style="display: none;">Riotous rookies (optional)
        <input type="number" id="riotousRookies" value="0" placeholder="only for Ogres/Snotlings" min="0" />
      </label>
      <label>Star player 1 (optional)
        <select id="star1"></select>
      </label>
      <label>Star player 2 (optional)
        <select id="star2"></select>
      </label>
    </div>
    <div class="row">
      <button id="generate">Generate</button>
      <span class="muted">Constraints mirror the CLI flags; change TV/requirements then generate.</span>
    </div>
    <div id="error" class="error"></div>
    <div id="results" class="results"></div>
    <div class="row">
      <button id="prevPage" disabled>Prev</button>
      <button id="nextPage" disabled>Next</button>
      <span id="pageInfo" class="muted"></span>
    </div>
  </div>

  <script>
    let rosters = {};
    let lastCombos = null;
    let currentPage = 1;
    let pageSize = 5;
    const teamSelect = document.getElementById('team');
    const starSelect1 = document.getElementById('star1');
    const starSelect2 = document.getElementById('star2');
    const bribesInput = document.getElementById('bribes');
    const apothecaryInput = document.getElementById('apothecary');
    const rookiesInput = document.getElementById('riotousRookies');
    const rookiesField = document.getElementById('riotousRookiesField');
    const positionalList = document.getElementById('positionalList');
    const rosterReady = loadRosters();
    const guideToggle = document.getElementById('guideToggle');
    const userGuide = document.getElementById('userGuide');
    document.querySelectorAll('input[type="number"]').forEach(applyStepper);

    teamSelect.addEventListener('change', () => {
      populateStarSelects(teamSelect.value);
      updateBribeInput(teamSelect.value);
      updateApothecaryInput(teamSelect.value);
      updateRiotousRookiesInput(teamSelect.value);
      populatePositionalList(teamSelect.value);
    });

    starSelect1.addEventListener('change', () => enforceDistinctStars(starSelect1, starSelect2));
    starSelect2.addEventListener('change', () => enforceDistinctStars(starSelect2, starSelect1));

    document.getElementById('generate').addEventListener('click', async () => {
      await rosterReady;
      const errorEl = document.getElementById('error');
      errorEl.textContent = '';
      try {
        const settings = collectSettings();
        const positions = buildPositions(
          rosters[settings.team],
          settings.stars,
          settings.maxStars,
          settings.bribes,
          settings.riotousRookies,
          settings.apothecary
        );
        const combos = generateCombos(positions, settings);
        lastCombos = { teamName: rosters[settings.team].name, settings, combos };
        currentPage = 1;
        pageSize = maxResults;
        renderResults(rosters[settings.team].name, settings, combos);
      } catch (err) {
        errorEl.textContent = err.message || String(err);
      }
    });

    document.getElementById('prevPage').addEventListener('click', () => {
      if (!lastCombos) return;
      if (currentPage > 1) {
        currentPage--;
        renderResults(lastCombos.teamName, lastCombos.settings, lastCombos.combos);
      }
    });

    document.getElementById('nextPage').addEventListener('click', () => {
      if (!lastCombos) return;
      const totalPages = Math.max(1, Math.ceil(lastCombos.combos.length / pageSize));
      if (currentPage < totalPages) {
        currentPage++;
        renderResults(lastCombos.teamName, lastCombos.settings, lastCombos.combos);
      }
    });

    guideToggle.addEventListener('click', () => {
      const hidden = userGuide.style.display === 'none';
      userGuide.style.display = hidden ? 'block' : 'none';
      guideToggle.textContent = hidden ? 'Hide guide' : 'Show guide';
    });

    async function loadRosters() {
      const errorEl = document.getElementById('error');
      try {
        const res = await fetch('bb2025_rosters.json');
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        rosters = addAliases(await res.json());
        populateTeamSelect(rosters);
        populateStarSelects(teamSelect.value);
        updateBribeInput(teamSelect.value);
        updateApothecaryInput(teamSelect.value);
        updateRiotousRookiesInput(teamSelect.value);
        populatePositionalList(teamSelect.value);
      } catch (err) {
        console.error('Failed to load rosters', err);
        errorEl.textContent = 'Could not load roster data.';
      }
    }

    function populateTeamSelect(rosterMap) {
      teamSelect.innerHTML = '';
      const seen = new Set();
      Object.entries(rosterMap)
        .sort((a, b) => a[1].name.localeCompare(b[1].name))
        .forEach(([key, team]) => {
          if (seen.has(team.name)) return;
          seen.add(team.name);
          const opt = document.createElement('option');
          opt.value = key;
          opt.textContent = team.name;
          teamSelect.appendChild(opt);
        });
      if (teamSelect.options.length) {
        // ensure a value is selected so downstream populators have a key
        teamSelect.selectedIndex = 0;
        const sel = teamSelect.value;
        populateStarSelects(sel);
        updateBribeInput(sel);
        updateApothecaryInput(sel);
        updateRiotousRookiesInput(sel);
      } else {
        populateStarSelects('');
        updateBribeInput('');
        updateApothecaryInput('');
        updateRiotousRookiesInput('');
      }
    }

    function populateStarSelects(teamKey) {
      const roster = rosters[teamKey];
      const stars = roster?.starPlayers || [];
      const selects = [starSelect1, starSelect2];
      selects.forEach(sel => {
        sel.innerHTML = '';
        const none = document.createElement('option');
        none.value = '';
        none.textContent = stars.length ? 'None' : 'No stars available';
        sel.appendChild(none);
        stars.forEach(sp => {
          const opt = document.createElement('option');
          opt.value = sp.name;
          opt.textContent = `${sp.name} (${sp.cost}k)`;
          sel.appendChild(opt);
        });
        sel.disabled = false; // keep enabled even if empty to avoid lock-out
      });
    }

    function getBribeInfo(teamKeyOrObj) {
      const roster = typeof teamKeyOrObj === 'string' ? rosters[teamKeyOrObj] : teamKeyOrObj;
      const inds = roster?.inducements || [];
      const found = inds.find(i => (i.name || '').toLowerCase().includes('bribe'));
      if (!found) return null;
      const maxMatch = /0-(\d+)/i.exec(found.name || '');
      const max = maxMatch ? Number(maxMatch[1]) : (found.max ?? 3);
      const cost = Number(found.cost) || 100;
      return { cost, max };
    }

    function getApothecaryInfo(teamKeyOrObj) {
      const roster = typeof teamKeyOrObj === 'string' ? rosters[teamKeyOrObj] : teamKeyOrObj;
      const pos = (roster?.positions || []).find(p => (p.name || '').toLowerCase() === 'apothecary');
      if (!pos) return null;
      const max = Number(pos.max ?? 1);
      const cost = Number(pos.cost) || 50;
      return { cost, max };
    }

    function getRiotousRookiesInfo(teamKeyOrObj) {
      const roster = typeof teamKeyOrObj === 'string' ? rosters[teamKeyOrObj] : teamKeyOrObj;
      const inds = roster?.inducements || [];
      const found = inds.find(i => (i.name || '').toLowerCase().includes('riotous rookies'));
      if (!found) return null;
      const maxMatch = /0-(\d+)/i.exec(found.name || '');
      const max = maxMatch ? Number(maxMatch[1]) : (found.max ?? 1);
      const cost = Number(found.cost) || 150;
      return { cost, max };
    }

    function updateBribeInput(teamKey) {
      const info = getBribeInfo(teamKey);
      if (!info) {
        bribesInput.value = '0';
        bribesInput.disabled = true;
        bribesInput.placeholder = 'not available';
        return;
      }
      bribesInput.disabled = false;
      bribesInput.min = '0';
      bribesInput.max = String(info.max);
      bribesInput.placeholder = `0..${info.max} @ ${info.cost}k`;
      const current = Number(bribesInput.value || 0);
      if (Number.isNaN(current) || current < 0 || current > info.max) {
        bribesInput.value = '0';
      }
    }

    function updateApothecaryInput(teamKey) {
      const info = getApothecaryInfo(teamKey);
      if (!info) {
        apothecaryInput.value = '';
        apothecaryInput.disabled = true;
        apothecaryInput.placeholder = 'not available';
        return;
      }
      apothecaryInput.disabled = false;
      apothecaryInput.min = '0';
      apothecaryInput.max = String(info.max);
      apothecaryInput.placeholder = `0..${info.max} @ ${info.cost}k`;
      const current = apothecaryInput.value === '' ? undefined : Number(apothecaryInput.value);
      if (current === undefined) return;
      if (Number.isNaN(current) || current < 0 || current > info.max) {
        apothecaryInput.value = '';
      }
    }

    function updateRiotousRookiesInput(teamKey) {
      const info = getRiotousRookiesInfo(teamKey);
      if (!info) {
        rookiesInput.value = '0';
        rookiesInput.disabled = true;
        rookiesInput.placeholder = 'not available';
        rookiesField.style.display = 'none';
        return;
      }
      rookiesField.style.display = 'block';
      rookiesInput.disabled = false;
      rookiesInput.min = '0';
      rookiesInput.max = String(info.max);
      rookiesInput.placeholder = `0..${info.max} @ ${info.cost}k`;
      const current = Number(rookiesInput.value || 0);
      if (Number.isNaN(current) || current < 0 || current > info.max) {
        rookiesInput.value = '0';
      }
    }

    function populatePositionalList(teamKey) {
      const roster = rosters[teamKey];
      positionalList.innerHTML = '';
      if (!roster) return;
      const players = (roster.positions || []).filter(p => (p.type ?? 'player') === 'player');
      players.forEach(pos => {
        const row = document.createElement('div');
        row.className = 'row';
        row.style.alignItems = 'center';
        row.style.gap = '8px';
        const label = document.createElement('div');
        label.textContent = `${pos.name} (max ${pos.max})`;
        const input = document.createElement('input');
        input.type = 'number';
        input.min = '0';
        input.max = String(pos.max);
        input.value = '0';
        input.dataset.name = pos.name;
        row.appendChild(label);
        row.appendChild(input);
        applyStepper(input);
        positionalList.appendChild(row);
      });
    }

    function addAliases(map) {
      const aliases = {
        humans: 'human',
        orcs: 'orc',
        dwarfs: 'dwarf',
      };
      Object.entries(aliases).forEach(([alias, key]) => {
        if (map[key]) map[alias] = map[key];
      });
      return map;
    }

    function enforceDistinct(changed, other) {
      if (changed.value && changed.value === other.value) {
        other.value = '';
      }
    }

    function enforceDistinctStars(changed, other) {
      if (changed.value && changed.value === other.value) {
        other.value = '';
      }
    }

    function applyStepper(input) {
      if (!input || input.dataset.stepper === '1') return;
      input.dataset.stepper = '1';
      const wrapper = document.createElement('div');
      wrapper.className = 'stepper';
      const dec = document.createElement('button');
      dec.type = 'button';
      dec.className = 'stepper-btn';
      dec.textContent = '-';
      const inc = document.createElement('button');
      inc.type = 'button';
      inc.className = 'stepper-btn';
      inc.textContent = '+';
      const parent = input.parentNode;
      parent.insertBefore(wrapper, input);
      wrapper.appendChild(dec);
      wrapper.appendChild(input);
      wrapper.appendChild(inc);

      const stepVal = Math.abs(Number(input.step) || 1) || 1;
      const toNum = (val) => {
        const parsed = Number(val);
        return Number.isNaN(parsed) ? 0 : parsed;
      };
      const clamp = (val) => {
        const min = input.min === '' || input.min === undefined ? -Infinity : Number(input.min);
        const max = input.max === '' || input.max === undefined ? Infinity : Number(input.max);
        return Math.max(min, Math.min(max, val));
      };
      const syncDisabled = () => {
        const disabled = input.disabled;
        dec.disabled = disabled;
        inc.disabled = disabled;
        wrapper.classList.toggle('stepper-disabled', disabled);
      };
      const adjust = (delta) => {
        const base = input.value === '' ? 0 : toNum(input.value);
        input.value = String(clamp(base + delta));
        input.dispatchEvent(new Event('input', { bubbles: true }));
        input.dispatchEvent(new Event('change', { bubbles: true }));
      };

      dec.addEventListener('click', () => adjust(-stepVal));
      inc.addEventListener('click', () => adjust(stepVal));
      syncDisabled();
      new MutationObserver(syncDisabled).observe(input, { attributes: true, attributeFilter: ['disabled'] });
    }

    function buildPositions(team, starNames, maxStars, bribes, riotousRookies, apothecaryCount) {
      const base = (team.positions || []).map(pos => {
        const copy = { ...pos };
        if ((copy.name || '').toLowerCase() === 'apothecary' && !copy.role) {
          copy.role = 'apothecary';
        }
        return copy;
      });
      if (apothecaryCount !== undefined) {
        base.forEach(pos => {
          if ((pos.name || '').toLowerCase() === 'apothecary') {
            const currentMax = Number(pos.max ?? apothecaryCount);
            pos.max = Math.min(currentMax, apothecaryCount);
          }
        });
      }
      const stars = (team.starPlayers || [])
        .filter(sp => starNames.map(s => s.toLowerCase()).includes(sp.name.toLowerCase()))
        .slice(0, maxStars)
        .map(sp => ({ name: sp.name, cost: sp.cost, max: 1, type: 'player', role: 'star' }));
      const bribeInfo = bribes && bribes > 0 ? getBribeInfo(team) : null;
      const bribe = bribeInfo ? [{ name: 'Bribe', cost: bribeInfo.cost, max: bribes, type: 'extra', role: 'bribe' }] : [];
      const rookieInfo = riotousRookies && riotousRookies > 0 ? getRiotousRookiesInfo(team) : null;
      const rookies = rookieInfo ? [{
        name: 'Riotous Rookies',
        cost: rookieInfo.cost,
        max: riotousRookies,
        type: 'extra',
        role: 'riotous-rookies',
      }] : [];
      return [...base, ...stars, ...bribe, ...rookies];
    }

    function collectSettings() {
      if (!Object.keys(rosters).length) throw new Error('Rosters not loaded yet.');
      const tv = Number(document.getElementById('tv').value);
      const minPlayers = Number(document.getElementById('minPlayers').value);
      const maxPlayers = Number(document.getElementById('maxPlayers').value);
      const maxResults = Number(document.getElementById('maxResults').value || 5);
      const sort = document.getElementById('sort').value;
      const rerollVal = document.getElementById('rerolls').value;
      const team = document.getElementById('team').value;
      const stars = Array.from(new Set([starSelect1.value, starSelect2.value].filter(Boolean)));
      const bribesVal = document.getElementById('bribes').value;
      const apothecaryVal = document.getElementById('apothecary').value;
      const rookiesVal = document.getElementById('riotousRookies').value;
      const requiredExtras = [];
      const positionalRequired = [];
      positionalList.querySelectorAll('input[type="number"]').forEach(input => {
        const name = input.dataset.name;
        const cnt = Number(input.value || 0);
        if (name && cnt > 0) positionalRequired.push({ name: name.toLowerCase(), count: cnt });
      });

      if (!team) throw new Error('Please select a team.');
      if (!tv || tv <= 0) throw new Error('Provide a positive TV in thousands.');
      if (maxPlayers < minPlayers) throw new Error('Max players must be >= min players.');
      const rerolls = rerollVal === '' ? undefined : Number(rerollVal);
      if (rerolls !== undefined && (Number.isNaN(rerolls) || rerolls < 0)) {
        throw new Error('Rerolls must be a non-negative number.');
      }
      const bribeInfo = getBribeInfo(team);
      const bribes = bribesVal === '' ? undefined : Number(bribesVal);
      if (bribes !== undefined) {
        if (Number.isNaN(bribes) || bribes < 0) throw new Error('Bribes must be non-negative.');
        if (bribeInfo && bribes > bribeInfo.max) throw new Error(`Bribes cannot exceed ${bribeInfo.max}.`);
        if (!bribeInfo && bribes > 0) throw new Error('Bribes not available for this team.');
      }
      const apothecaryInfo = getApothecaryInfo(team);
      const apothecary = apothecaryVal === '' ? undefined : Number(apothecaryVal);
      if (apothecary !== undefined) {
        if (Number.isNaN(apothecary) || apothecary < 0) throw new Error('Apothecary must be non-negative.');
        if (!apothecaryInfo) throw new Error('Apothecary not available for this team.');
        if (apothecaryInfo && apothecary > apothecaryInfo.max) throw new Error(`Apothecary cannot exceed ${apothecaryInfo.max}.`);
      }
      const rookiesInfo = getRiotousRookiesInfo(team);
      const riotousRookies = rookiesVal === '' ? 0 : Number(rookiesVal);
      if (Number.isNaN(riotousRookies) || riotousRookies < 0) throw new Error('Riotous rookies must be non-negative.');
      if (rookiesInfo && riotousRookies > rookiesInfo.max) throw new Error(`Riotous rookies cannot exceed ${rookiesInfo.max}.`);
      if (!rookiesInfo && riotousRookies > 0) throw new Error('Riotous rookies not available for this team.');

      const combinedRequired = [...positionalRequired];
      if (stars.length > 2) throw new Error('Select at most 2 stars.');
      const availableStarNames = (rosters[team].starPlayers || []).map(s => s.name.toLowerCase());
      const missingStars = stars.filter(s => !availableStarNames.includes(s.toLowerCase()));
      if (missingStars.length) throw new Error(`Unknown star(s): ${missingStars.join(', ')}`);
      if (bribes !== undefined && bribes > 0) {
        requiredExtras.push({ name: 'bribe', count: bribes });
      }
      if (apothecary !== undefined && apothecary > 0) {
        requiredExtras.push({ name: 'apothecary', count: apothecary });
      }

      return {
        team,
        tv,
        minPlayers,
        maxPlayers,
        maxResults,
        sort,
        rerolls,
        required: combinedRequired,
        requiredExtras,
        requireMode: 'all',
        requireExtraMode: 'all',
        stars,
        bribes,
        apothecary,
        riotousRookies,
        maxStars: 2,
      };
    }

    function renderResults(teamName, settings, combos) {
      const list = Array.isArray(combos) ? combos : [];
      const effectivePageSize = Number(settings.maxResults) > 0 ? Number(settings.maxResults) : (pageSize || 5);
      pageSize = effectivePageSize;
      const totalPages = list.length ? Math.ceil(list.length / effectivePageSize) : 1;
      currentPage = Math.min(Math.max(1, currentPage), totalPages);
      const container = document.getElementById('results');
      container.innerHTML = '';
      const header = document.createElement('div');
      header.className = 'muted';
      header.textContent = `Team: ${teamName} â€¢ Target TV: ${settings.tv}k â€¢ Results: ${list.length || 0}`;
      container.appendChild(header);

      const pageInfo = document.getElementById('pageInfo');
      const prevBtn = document.getElementById('prevPage');
      const nextBtn = document.getElementById('nextPage');
      pageInfo.textContent = list.length ? `Page ${currentPage} of ${totalPages}` : '';
      prevBtn.disabled = currentPage <= 1 || !list.length;
      nextBtn.disabled = currentPage >= totalPages || !list.length;

      if (!list.length) {
        const none = document.createElement('div');
        none.className = 'error';
        const stars = settings.stars && settings.stars.length ? ` (selected stars required: ${settings.stars.join(', ')})` : '';
        none.textContent = `No combinations found under the given constraints${stars ? '; try raising TV or lowering min players so the stars fit' : ''}.`;
        container.appendChild(none);
        return;
      }

      const start = (currentPage - 1) * effectivePageSize;
      const pageItems = list.slice(start, start + effectivePageSize);

      pageItems.forEach((combo, idx) => {
        const card = document.createElement('div');
        card.className = 'result';
        const title = document.createElement('div');
        title.innerHTML = `<strong>#${start + idx + 1}</strong> | Cost: ${combo.cost}k | Players: ${combo.totalPlayers}`;
        card.appendChild(title);

        const pills = document.createElement('div');
        pills.style.marginTop = '6px';
        pills.innerHTML = `
          <span class="pill">positionals: ${combo.positionals}</span>
          <span class="pill">linemen: ${combo.linemen}</span>
          <span class="pill">rerolls: ${combo.rerolls}</span>
        `;
        card.appendChild(pills);

        const list = document.createElement('ul');
        list.className = 'list';
        combo.players
          .filter(p => p.count > 0)
          .forEach(p => {
            const li = document.createElement('li');
            const extraBodies = p.addsPlayers ? ` (+${p.addsPlayers * p.count} players)` : '';
            li.textContent = `${p.count} x ${p.name} @ ${p.cost}k${extraBodies}`;
            list.appendChild(li);
          });
        card.appendChild(list);

        const copyBtn = document.createElement('button');
        copyBtn.type = 'button';
        copyBtn.className = 'icon-btn secondary';
        copyBtn.setAttribute('aria-label', 'Copy roster to clipboard');
        copyBtn.style.marginTop = '8px';
        copyBtn.textContent = 'ðŸ“‹';
        copyBtn.addEventListener('click', () => copyRosterToClipboard(teamName, settings, combo, start + idx + 1));
        const sendBtn = document.createElement('button');
        sendBtn.type = 'button';
        sendBtn.className = 'icon-btn secondary';
        sendBtn.setAttribute('aria-label', 'Populate this roster on BBTC');
        sendBtn.style.marginTop = '8px';
        sendBtn.textContent = 'â†— BBTC';
        sendBtn.addEventListener('click', () => exportRosterToBbtc(settings.team, teamName, settings, combo, start + idx + 1));
        const actions = document.createElement('div');
        actions.className = 'row';
        actions.style.gap = '8px';
        actions.style.flexWrap = 'wrap';
        actions.appendChild(copyBtn);
        actions.appendChild(sendBtn);
        card.appendChild(actions);

        container.appendChild(card);
      });

    }

    async function copyRosterToClipboard(teamName, settings, combo, rank) {
      const lines = combo.players
        .filter(p => p.count > 0)
        .map(p => {
          const extraBodies = p.addsPlayers ? ` (+${p.addsPlayers * p.count} players)` : '';
          return `${p.count} x ${p.name} @ ${p.cost}k${extraBodies}`;
        });
      const header = `#${rank} | ${teamName}\nCost: ${combo.cost}k | Players: ${combo.totalPlayers}\nTV: ${settings.tv}k`;
      const text = [header, ...lines].join('\n');
      try {
        await navigator.clipboard.writeText(text);
      } catch (err) {
        const fallback = legacyCopy(text);
        if (!fallback) {
          console.error('Clipboard copy failed', err);
          alert('Could not copy roster to clipboard. Please copy manually.');
        }
      }
    }

    function legacyCopy(text) {
      try {
        const ta = document.createElement('textarea');
        ta.value = text;
        ta.style.position = 'fixed';
        ta.style.top = '-1000px';
        ta.style.left = '-1000px';
        document.body.appendChild(ta);
        ta.focus();
        ta.select();
        const ok = document.execCommand('copy');
        document.body.removeChild(ta);
        return ok;
      } catch (err) {
        console.error('Legacy copy failed', err);
        return false;
      }
    }

    function sanitizeStarName(name) {
      if (!name) return '';
      // Strip affiliation suffixes the BBTC UI does not show.
      return name.replace(/\s+(Old World Classic|Lustrian Superleague|Badlands Brawl|Worlds Edge Superleague|Sylvanian Spotlight|Elven Kingdoms|Underworld Challenge|Halfling Thimble Cup|Favoured of [^,]+)$/i, '').trim();
    }

    function buildBbtcPayload(teamKey, teamName, settings, combo, rank) {
      const players = combo.players
        .filter(p => (p.type ?? 'player') === 'player' && p.count > 0)
        .map(p => ({ name: sanitizeStarName(p.name), count: p.count }));
      const extras = combo.players
        .filter(p => (p.type ?? 'player') === 'extra' && p.count > 0)
        .map(p => ({ name: p.name, role: p.role || '', count: p.count }));
      const rerollExtra = extras.find(e => (e.name || '').toLowerCase().includes('reroll'));
      const bribesExtra = extras.find(e => (e.role === 'bribe') || (e.name || '').toLowerCase().includes('bribe'));
      const rookiesExtra = extras.find(e => (e.role === 'riotous-rookies') || (e.name || '').toLowerCase().includes('riotous rookies'));
      const apothecaryExtra = extras.find(e => (e.role === 'apothecary') || (e.name || '').toLowerCase().includes('apothecary'));
      return {
        teamSlug: teamKey,
        teamName,
        rank,
        players,
        rerolls: combo.rerolls ?? rerollExtra?.count ?? 0,
        bribes: bribesExtra?.count ?? 0,
        apothecary: apothecaryExtra?.count ?? 0,
        riotousRookies: rookiesExtra?.count ?? 0,
      };
    }

    function buildBbtcInjectionScript(payload) {
      const injector = (payload) => {
        const normalize = (str) => (str || '').toLowerCase().replace(/[^a-z0-9+ ]+/g, ' ').replace(/\s+/g, ' ').trim();
        const endpoint = (typeof window.getAjaxEndpoint === 'function') ? window.getAjaxEndpoint() : '/ajax';
        const log = (msg) => console.log(`[RosterLabâ†’BBTC] ${msg}`);
        const requiredPath = `/team/bb2025/${payload.teamSlug}`;
        if (!location.pathname.includes(requiredPath)) {
          alert(`Open https://bbtc.pl${requiredPath} first, then paste again.`);
          log(`Please navigate to ${requiredPath} before importing.`);
          return;
        }
        if (typeof window.CallAjax !== 'function') {
          alert('BBTC scripts not ready yet. Wait for the page to finish loading, then paste again.');
          return;
        }

        const missing = [];
        const selects = Array.from(document.querySelectorAll('#playersTable select.selectpicker'));
        if (!selects.length) {
          alert('Could not find the players table on BBTC.');
          return;
        }

        const optionMap = {};
        selects[0].querySelectorAll('option').forEach(opt => {
          if (!opt.value) return;
          optionMap[normalize(opt.textContent)] = opt.value;
        });

        const findPlayerId = (name) => {
          const target = normalize(name);
          if (optionMap[target]) return optionMap[target];
          const fuzzy = Object.entries(optionMap).find(([optName]) => optName.includes(target) || target.includes(optName));
          return fuzzy ? fuzzy[1] : null;
        };

        const queueDelete = () => {
          selects.forEach(sel => {
            const currentVal = sel.value;
            if (!currentVal || currentVal === '0') return;
            const position = Number(sel.id.replace('player-select-', ''));
            const data = { operation: 'delete-player', app: 'team', action: 'create', data: { position }, busy: { area: 'player-select', id: sel.id }, previous: { area: 'player-select', id: sel.id, value: currentVal } };
            window.CallAjax(endpoint, data, window.refreshPlayerRow);
          });
        };

        const queuePlayers = () => {
          let slot = 1;
          payload.players.forEach(player => {
            const playerId = findPlayerId(player.name);
            if (!playerId) {
              missing.push(`Player not found: ${player.name}`);
              return;
            }
            for (let i = 0; i < player.count; i++) {
              if (slot > selects.length) {
                missing.push(`Not enough slots for ${player.name}`);
                return;
              }
              const data = {
                operation: 'add-player',
                app: 'team',
                action: 'create',
                data: { position: slot, playerId },
                busy: { area: 'player-select', id: `player-select-${slot}` },
                previous: { area: 'player-select', id: `player-select-${slot}`, value: '0' },
              };
              window.CallAjax(endpoint, data, window.refreshPlayerRow);
              slot += 1;
            }
          });
        };

        const setAreaQuantity = (tableSelector, targetName, value, fallbackArea) => {
          if (value === undefined || value === null) return;
          const normTarget = normalize(targetName);
          const row = Array.from(document.querySelectorAll(`${tableSelector} tbody tr`)).find(tr => normalize(tr.textContent || '').includes(normTarget));
          if (!row) {
            if (value > 0) missing.push(`Could not find row for ${targetName}`);
            return;
          }
          const area = row.closest('[data-bb-area]')?.getAttribute('data-bb-area') || fallbackArea;
          const id = row.getAttribute('data-bb-id');
          const data = { operation: `update-${area}-quantity`, app: 'team', action: 'create', data: { id, value, area } };
          window.CallAjax(endpoint, data, window.updateArea);
        };

        queueDelete();
        queuePlayers();
        setAreaQuantity('#sidelineTable', 're-roll', payload.rerolls, 'sideline');
        setAreaQuantity('#sidelineTable', 'apothecary', payload.apothecary, 'sideline');
        setAreaQuantity('#inducementsTable', 'bribe', payload.bribes, 'inducements');
        setAreaQuantity('#inducementsTable', 'riotous rookies', payload.riotousRookies, 'inducements');

        if (missing.length) {
          log(`Completed with notes:\\n- ${missing.join('\\n- ')}`);
          alert(`Imported with notes:\\n${missing.join('\\n')}`);
        } else {
          log(`Queued roster import for ${payload.teamName || payload.teamSlug}. Watch the BBTC page update.`);
        }
      };

      return `(${injector.toString()})(${JSON.stringify(payload)});`;
    }

    async function exportRosterToBbtc(teamKey, teamName, settings, combo, rank) {
      const payload = buildBbtcPayload(teamKey, teamName, settings, combo, rank);
      const script = buildBbtcInjectionScript(payload);
      let copied = false;
      try {
        await navigator.clipboard.writeText(script);
        copied = true;
      } catch (err) {
        copied = legacyCopy(script);
        if (!copied) {
          console.warn('RosterLab BBTC script (copy manually):\n', script);
        }
      }
      const targetUrl = `https://bbtc.pl/team/bb2025/${teamKey}`;
      const consoleHowTo = [
        'On mac: press Cmd+Option+I (Chrome/Firefox/Safari) to open DevTools, then click the Console tab. On Windows/Linux: press Ctrl+Shift+I or F12, then select Console.',
        'Click inside the console prompt (usually a > line), paste the script (Cmd+V / Ctrl+V), and press Enter.',
        'Wait a few seconds while the page updates; watch the console for any â€œRosterLabâ†’BBTCâ€ messages or missing-player notes.',
        'On mobile: browsers generally block console access; use a desktop/laptop to run the script.',
      ].join('\n');
      const note = (copied
        ? `BBTC fill script copied. Open ${targetUrl}, paste into the browser console, and press Enter to queue the roster.`
        : `Could not copy automatically. Open ${targetUrl} and paste the script shown in the console to import.`) + '\n\n' + consoleHowTo;
      alert(note);
      window.open(targetUrl, '_blank', 'noopener');
    }

    function parseRequirements(str) {
      const pieces = str.split(',');
      const parsed = pieces
        .map(piece => {
          const parts = piece.split(':');
          if (!parts[0]) return null;
          const name = parts[0].trim().toLowerCase();
          const count = parts[1] ? Number(parts[1]) : 1;
          if (!name || Number.isNaN(count) || count <= 0) return null;
          return { name, count };
        })
        .filter(Boolean);
      return parsed.length ? parsed : null;
    }

    function generateCombos(positions, settings) {
      const results = [];
      const path = [];

      function dfs(index, remainingCost, totalPlayers, starCount) {
        if (remainingCost < 0 || totalPlayers > settings.maxPlayers) return;
        if (index >= positions.length || remainingCost === 0) {
          if (totalPlayers < settings.minPlayers || totalPlayers > settings.maxPlayers) return;
          const spent = settings.tv - remainingCost;
          const summary = path.reduce(
            (acc, p) => {
              if (!p.count) return acc;
              const type = p.type ?? 'player';
              const name = (p.name || '').toLowerCase();
              if (type === 'extra') {
                if (name === 'reroll') acc.rerolls += p.count;
                if (name.includes('bribe')) acc.bribes += p.count;
                if (name.includes('apothecary')) acc.apothecary += p.count;
              }
              if (type === 'player') {
                const isLineman = p.role === 'lineman' || name.includes('lineman');
                const isStar = p.role === 'star';
                if (isStar) {
                  acc.stars += p.count;
                  acc.starCounts[name] = (acc.starCounts[name] ?? 0) + p.count;
                }
                if (isLineman) acc.lineman += p.count;
                else acc.positionals += p.count;
              }
              const bigGuyTeams = ['old-world-alliance', 'chaos-chosen', 'chaos-renegade', 'underworld-denizens'];
              if (bigGuyTeams.includes(settings.team)) {
                const isTreeman = name.includes('treeman');
                const isOgre = name === 'ogre';
                const isTroll = name === 'troll';
                const isMinotaur = name === 'minotaur';
                const isRatOgre = name.includes('rat ogre');
                if (isTreeman || isOgre || isTroll || isMinotaur || isRatOgre) acc.bigGuys += p.count;
              }
              if (settings.required && settings.required.length) {
                const req = settings.required.find(r => r.name === name);
                if (req) acc.required[name] = (acc.required[name] ?? 0) + p.count;
              }
              if (settings.requiredExtras && settings.requiredExtras.length) {
                const req = settings.requiredExtras.find(r => r.name === name);
                if (req) acc.requiredExtras[name] = (acc.requiredExtras[name] ?? 0) + p.count;
              }
              return acc;
            },
            { rerolls: 0, bribes: 0, apothecary: 0, positionals: 0, lineman: 0, stars: 0, bigGuys: 0, required: {}, requiredExtras: {}, starCounts: {} }
          );

          const missingRequired = settings.required && settings.required.some(
            r => (summary.required[r.name] ?? 0) < r.count
          );
          const missingRequiredExtras = settings.requiredExtras && settings.requiredExtras.some(
            r => (summary.requiredExtras[r.name] ?? 0) < r.count
          );

          const failsRequiredAny = settings.requireMode === 'any' &&
            settings.required.length > 0 &&
            settings.required.every(r => (summary.required[r.name] ?? 0) < r.count);
          const failsRequiredAll = settings.requireMode === 'all' && missingRequired;

          const failsExtrasAny = settings.requireExtraMode === 'any' &&
            settings.requiredExtras.length > 0 &&
            settings.requiredExtras.every(r => (summary.requiredExtras[r.name] ?? 0) < r.count);
          const failsExtrasAll = settings.requireExtraMode === 'all' && missingRequiredExtras;
          let exceedsBigGuyLimit = false;
          if (settings.team === 'old-world-alliance' || settings.team === 'chaos-chosen') {
            exceedsBigGuyLimit = summary.bigGuys > 1;
          } else if (settings.team === 'chaos-renegade') {
            exceedsBigGuyLimit = summary.bigGuys > 3;
          } else if (settings.team === 'underworld-denizens') {
            exceedsBigGuyLimit = summary.bigGuys > 1;
          }

          if (
            (settings.rerolls !== undefined && summary.rerolls !== settings.rerolls) ||
            settings.stars.some(s => (summary.starCounts[s.toLowerCase()] ?? 0) < 1) ||
            summary.stars > settings.maxStars ||
            failsRequiredAny ||
            failsRequiredAll ||
            failsExtrasAny ||
            failsExtrasAll ||
            exceedsBigGuyLimit
          ) {
            return;
          }

          results.push({
            players: [...path],
            cost: spent,
            totalPlayers,
            rerolls: summary.rerolls,
            bribes: summary.bribes,
            positionals: summary.positionals,
            linemen: summary.lineman,
          });
          return;
        }

        const pos = positions[index];
        const isPlayer = (pos.type ?? 'player') === 'player';
        const isStar = pos.role === 'star';
        const addedPerUnit = isPlayer ? 1 : 0;
        const maxByCost = pos.cost > 0 ? Math.floor(remainingCost / pos.cost) : pos.max;
        const playerRoom = addedPerUnit > 0 ? Math.floor((settings.maxPlayers - totalPlayers) / addedPerUnit) : Number.MAX_SAFE_INTEGER;
        const starRoom = isStar ? settings.maxStars - starCount : Number.MAX_SAFE_INTEGER;
        const maxCount = Math.min(pos.max, maxByCost, playerRoom, starRoom);

        for (let count = 0; count <= maxCount; count++) {
          path.push({ name: pos.name, count, cost: pos.cost, type: pos.type, role: pos.role });
          const nextPlayers = totalPlayers + count * addedPerUnit;
          const nextStars = isStar ? starCount + count : starCount;
          dfs(index + 1, remainingCost - count * pos.cost, nextPlayers, nextStars);
          path.pop();
        }
      }

      dfs(0, settings.tv, 0, 0);

      return results
        .filter(r => r.totalPlayers <= settings.maxPlayers)
        .sort((a, b) => {
          if (settings.sort === 'players') {
            return (
              b.totalPlayers - a.totalPlayers ||
              b.positionals - a.positionals ||
              a.linemen - b.linemen ||
              b.cost - a.cost ||
              b.rerolls - a.rerolls ||
              0
            );
          }
          return (
            b.cost - a.cost ||
            b.totalPlayers - a.totalPlayers ||
            b.positionals - a.positionals ||
            a.linemen - b.linemen ||
            a.bribes - b.bribes ||
            b.rerolls - a.rerolls ||
            0
          );
        });
    }

  </script>
</body>
</html>
